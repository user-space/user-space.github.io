<!doctype html>
<html>
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <title>REST API Guide | Parse</title>

  <link rel="apple-touch-icon" sizes="57x57" href="https://parse.com/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="114x114" href="https://parse.com/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="72x72" href="https://parse.com/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="144x144" href="https://parse.com/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="60x60" href="https://parse.com/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="120x120" href="https://parse.com/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="76x76" href="https://parse.com/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="152x152" href="https://parse.com/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://parse.com/apple-touch-icon-180x180.png">
  <meta name="apple-mobile-web-app-title" content="Parse">
  <link rel="icon" type="image/png" href="https://parse.com/favicon-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="https://parse.com/favicon-160x160.png" sizes="160x160">
  <link rel="icon" type="image/png" href="https://parse.com/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="https://parse.com/favicon-16x16.png" sizes="16x16">
  <link rel="icon" type="image/png" href="https://parse.com/favicon-32x32.png" sizes="32x32">
  <meta name="msapplication-TileColor" content="#5298fc">
  <meta name="msapplication-TileImage" content="/mstile-144x144.png">
  <meta name="application-name" content="Parse">

  <meta name="theme-color" content="#5298fc">

      <!-- CSS -->
      <!-- build:css -->
      <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css">
      <link href="/docs/css/docs.css" rel="stylesheet" />
      <link href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" rel="stylesheet" />
      <!-- endbuild -->

      <!--[if lte IE 9]>
        <script src="//cdnjs.cloudflare.com/ajax/libs/classlist/2014.01.31/classList.min.js"></script>
      <![endif]-->

      <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script>

  <!--[if lt IE 8]>
      <link rel="stylesheet" type="text/css" href="/stylesheets/ie7.css" />
  <![endif]-->
  <!--[if IE 8]>
      <link rel="stylesheet" type="text/css" href="/stylesheets/ie8.css" />
  <![endif]-->
  <!--[if lt IE 10]>
      <link rel="stylesheet" type="text/css" href="/stylesheets/ie89.css" />
  <![endif]-->
  <script>if(Function('/*@cc_on return document.documentMode===10@*/')()){document.documentElement.className+=' ie10';}</script>

  <meta name="csrf-param" content="authenticity_token">
  <meta name="csrf-token" content="KxDoKysxiXDIRV8VXwDYlQStDGzjbGZ24y6ZgQLYAsE=">
  <meta name="description" content="Focus on creating unique &amp; engaging apps on any platform. We take care of everything else your app needs, from the core of your app to analytics and push notifications.">
  <meta name="keywords" content="backend, mobile, development, server, code">
  <meta property="fb:app_id" content="361736430535656">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Parse">
  <meta property="og:image" content="/docs/assets/images/social.jpg">
  <meta property="og:description" content="Focus on creating unique &amp; engaging apps on any platform. We take care of everything else your app needs, from the core of your app to analytics and push notifications.">
  <meta property="og:url" content="/rest/guide/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

  <body class="pure p_docs p_docs_show_guide user_logged_in" style="position: relative;">
  <div class="site__wrapper">
    <div class="site__content">

      <aside class="site__menu">
    <nav class="site__menu__nav">
        <ul>
            <li><a href="/migration">Migration Guide</a></li>
            <li><a href="/help">Help</a></li>
            <li><a href="/docs">Docs</a></li>
            <li><a href="http://blog.parse.com/">Blog</a></li>
        </ul>
    </nav>

    <div class="site__menu__socials">
        <h4 class="h4">Stay Connected</h4>

        <ul>
            <li>
                <a href="https://www.facebook.com/parseit">
                    <svg class="icon icon-fb"><use xlink:href="/docs/assets/symbols.svg#fb"></use></svg>
                </a>
            </li>
            <li>
                <a href="https://twitter.com/parseit">
                    <svg class="icon icon-twitter"><use xlink:href="/docs/assets/symbols.svg#twitter"></use></svg>
                </a>
            </li>
            <li>
                <a href="https://parseplatform.github.io">
                    <svg class="icon icon-github"><use xlink:href="/docs/assets/symbols.svg#github"></use></svg>
                </a>
            </li>
            <li>
                <a href="http://stackoverflow.com/questions/tagged/parse.com">
                    <svg class="icon icon-stack-overflow"><use xlink:href="/docs/assets/symbols.svg#stack-overflow"></use></svg>
                </a>
            </li>
        </ul>

        <p class="site__menu__build-together">Let&rsquo;s build together.</p>
    </div>
</aside>

      <div class="content__wrapper">
        <header class="site__header site__header--white">
    <div class="container">

        <a href="/" class="header-logo">
            <span class="hidden">Parse</span>
            <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
            	 viewBox="0 0 152 60" style="enable-background:new 0 0 152 60;" xml:space="preserve">
            <g>
            	<path class="line one" d="M23.072,39.678c-0.011,3.348-2.395,4.615-4.909,4.615c-2.851,0-4.541-1.701-4.541-4.357
            		c0-2.964,2.031-4.667,5.35-4.725h13.611c6.428,0.079,10.137-5.391,10.137-9.953c0-4.598-3.485-9.598-9.622-9.842
            		c-6.083-0.242-9.99,5.281-9.99,11.167v3.863"/>
            	<path class="line two" d="M23.072,39.678c-0.011,3.348-2.395,4.615-4.909,4.615c-2.851,0-4.541-1.701-4.541-4.357
            		c0-2.964,2.031-4.667,5.35-4.725h13.611c6.428,0.079,10.137-5.391,10.137-9.953c0-4.598-3.485-9.598-9.622-9.842
            		c-6.083-0.242-9.99,5.281-9.99,11.167v3.863"/>
            	<path class="line three" d="M23.072,39.678c-0.011,3.348-2.395,4.615-4.909,4.615c-2.851,0-4.541-1.701-4.541-4.357
            		c0-2.964,2.031-4.667,5.35-4.725h13.611c6.428,0.079,10.137-5.391,10.137-9.953c0-4.598-3.485-9.598-9.622-9.842
            		c-6.083-0.242-9.99,5.281-9.99,11.167v3.863"/>
            	<path class="st1" d="M151.88,31.106c0-4.561-2.575-7.835-7.173-7.872c-5.665-0.037-9.197,4.12-9.197,10.484v0.11
            		c0,6.033,3.863,9.601,9.601,9.601c1.839,0,4.083-0.405,5.739-1.177v-3.568c-1.839,0.956-3.752,1.398-5.408,1.398
            		c-3.568,0-6.07-1.803-6.18-5.959h12.36C151.807,33.056,151.88,32.026,151.88,31.106z M148.312,31.07h-8.829
            		c0.625-3.053,2.354-4.745,4.966-4.745c2.575,0,3.863,1.729,3.863,4.561V31.07z"/>
            	<path class="st1" d="M125.725,34.712l0.405,0.147c2.869,1.03,3.531,1.655,3.531,2.906c0,1.471-0.993,2.428-3.458,2.428
            		c-1.986,0-4.12-0.662-6.364-1.692v3.752c1.803,0.699,4.12,1.177,6.364,1.177c4.819,0,7.21-2.428,7.21-5.812
            		c0-2.943-1.471-4.525-5.408-5.959l-0.405-0.147c-3.127-1.14-3.752-1.655-3.752-2.869c0-1.361,0.956-2.281,3.237-2.281
            		c1.839,0,3.642,0.589,5.408,1.435v-3.531c-1.582-0.625-3.348-1.03-5.26-1.03c-4.598,0-7.1,2.575-7.1,5.886
            		C120.134,31.695,121.679,33.24,125.725,34.712"/>
            	<path class="st1" d="M110.863,29.892c1.288-2.023,3.09-3.016,5.26-3.016c0.773,0,1.508,0.11,2.17,0.331v-3.384
            		c-0.625-0.258-1.361-0.405-2.134-0.405c-2.281,0-4.01,1.03-5.518,3.09l-0.258-2.869h-3.164v19.386h3.642V29.892z"/>
            	<path class="st1" d="M96.481,23.197c-2.281,0-4.672,0.699-6.474,1.692v3.605c2.023-1.251,4.378-2.023,6.254-2.023
            		c2.612,0,3.679,1.14,3.679,3.274v1.619c-5.334,0.147-8.461,1.03-10.116,2.685c-1.177,1.14-1.692,2.685-1.692,4.267
            		c0,3.274,2.354,5.15,5.702,5.15c2.244,0,4.378-0.92,6.327-2.796l0.221,2.354h3.164V30.003
            		C103.544,25.405,101.263,23.197,96.481,23.197z M99.938,37.728c-1.471,1.619-3.2,2.722-5.297,2.722
            		c-1.729,0-2.833-0.883-2.833-2.428c0-2.281,1.876-3.642,8.13-3.826V37.728z"/>
            	<path class="st1" d="M77.609,17.643h-8.571v25.383h3.826v-8.314h4.745c5.923,0,9.491-3.164,9.491-8.498V26.14
            		C87.1,20.806,83.532,17.643,77.609,17.643z M83.311,26.214c0,3.421-1.986,5.04-5.444,5.04h-5.003V21.101h5.04
            		c3.421,0,5.408,1.619,5.408,5.04V26.214z"/>
            	<path class="st1" d="M27.838,2.192C12.204,2.192-0.12,14.589-0.12,30.15c0,15.597,12.323,27.958,27.958,27.958
            		c15.634,0,27.958-12.36,27.958-27.958C55.795,14.589,43.472,2.192,27.838,2.192z M32.473,36.955H18.752
            		c-1.986,0-3.164,1.214-3.164,3.017c0,1.582,1.067,2.722,2.612,2.722c1.766,0,2.796-1.214,2.906-3.016h4.01
            		c-0.184,4.341-2.906,6.658-6.953,6.658c-3.789,0-6.585-2.575-6.585-6.401c0-3.973,2.98-6.769,7.394-6.769h13.611
            		c4.598,0,8.093-3.348,8.093-7.909c0-4.598-3.127-7.799-7.578-7.799c-4.414,0-7.946,3.237-7.946,9.123v3.863h-4.046v-3.863
            		c0-7.872,5.076-12.986,12.066-12.986c6.695,0,11.551,4.782,11.551,11.588C44.723,32.026,39.499,36.955,32.473,36.955z"/>
            </g>
            </svg>
        </a>

        <a href="javascript:;" class="header-hamburger" data-menu-trigger="toggle">
            <span class="header-hamburger__wrap">
                <span class="header-hamburger__line--top"></span>
                <span class="header-hamburger__line--middle"></span>
                <span class="header-hamburger__line--bottom"></span>

                <span class="header-hamburger__line--arrow-top"></span>
                <span class="header-hamburger__line--arrow-bottom"></span>
            </span>
        </a>

        <ul class="header-nav">
            <li><a href="https://parse.com/migration">Migration Guide</a></li>
            <li><a href="/docs/">Docs</a></li>
            <li><a href="http://blog.parse.com">Blog</a></li>
            <li><a href="https://parse.com/help">Help</a></li>
        </ul>

    </div><!-- container -->
</header>

        <aside class="hero hero--docs rest_docs_header">
          <div class="grid-container">
            <div class="col-md--6 col-lg--9">
              <p class="h1 h1--white" data-ignore-from-select>
                <span>REST <em>Guide</em></span>

                <a href="/docs/" class="btn btn--back">
                  <span class="hide-mobile">Browse all platforms</span>
                  <span class="show-mobile">Browse</span>
                </a>

                <svg class="icon icon-rest"><use xlink:href="/docs/assets/symbols.svg#rest"></use></svg>

              </p>
            </div>
          </div>
        </aside><!-- .hero -->

        <div class="guide" data-nav-waypoint>
          <div id="mobile_toc" class="">
          	<select></select>
          </div>

          <div class="grid-container">
            <div class="col-md--6 col-lg--9">
              <div class="guide_content">
                <div id="toc">
                  <div style="overflow-y: scroll; height: 100%;">
                    <div class="top_links">
                    
                      <a href="https://parse.com/apps/quickstart">Quickstart<i class="icon_minimize"></i></a>
                    
                    
                    
                      <!-- .algolia-search-wrapper -->
                      <div class="algolia-search-wrapper">
                        <input id="algolia-doc-search" class="rest_docs_docsearch" tabindex="0" type="text" placeholder="Search..." />
                      </div><!-- .algolia-search-wrapper -->
                    </div>
                  </div>
                </div>

                <div class="wysiwyg-content">
                  
                    
                    <h1 id="getting-started">Getting Started</h1>

<p>The REST API lets you interact with Parse Server from anything that can send an HTTP request. There are many things you can do with the REST API. For example:</p>

<ul>
  <li>A mobile website can access Parse Server data from JavaScript.</li>
  <li>A web server can show data from Parse Server on a website.</li>
  <li>You can upload large amounts of data that will later be consumed in a mobile app.</li>
  <li>You can download recent data to run your own custom analytics.</li>
  <li>Applications written in any programming language can interact with data on Parse Server.</li>
</ul>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="quick-reference">Quick Reference</h1>

<p>All API access is over HTTPS, and accessed via the <code class="highlighter-rouge">https://api.parse.com</code> domain. The relative path prefix <code class="highlighter-rouge">/1/</code> indicates that we are currently using version 1 of the API.</p>

<h2 id="objects">Objects</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP Verb</th>
      <th>Functionality</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">/1/classes/&lt;className&gt;</code></td>
      <td>POST</td>
      <td><a href="#objects-creating-objects">Creating Objects</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/classes/&lt;className&gt;/&lt;objectId&gt;</code></td>
      <td>GET</td>
      <td><a href="#objects-retrieving-objects">Retrieving Objects</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/classes/&lt;className&gt;/&lt;objectId&gt;</code></td>
      <td>PUT</td>
      <td><a href="#objects-updating-objects">Updating Objects</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/classes/&lt;className&gt;</code></td>
      <td>GET</td>
      <td><a href="#queries">Queries</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/classes/&lt;className&gt;/&lt;objectId&gt;</code></td>
      <td>DELETE</td>
      <td><a href="#objects-deleting-objects">Deleting Objects</a></td>
    </tr>
  </tbody>
</table>

<h2 id="users">Users</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP Verb</th>
      <th>Functionality</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">/1/users</code></td>
      <td>POST</td>
      <td><a href="#users-signingup">Signing Up</a> <br /><a href="#users-linking-users">Linking Users</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/login</code></td>
      <td>GET</td>
      <td><a href="#users-logging-in">Logging In</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/logout</code></td>
      <td>POST</td>
      <td><a href="#sessions-deleting-sessions">Logging Out</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/users/&lt;objectId&gt;</code></td>
      <td>GET</td>
      <td><a href="#users-retrieving-users">Retrieving Users</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/users/me</code></td>
      <td>GET</td>
      <td><a href="#users-validating-session-tokens-retrieving-current-user">Validating Session Tokens</a> <br /><a href="#users-retrieving-users">Retrieving Current User</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/users/&lt;objectId&gt;</code></td>
      <td>PUT</td>
      <td><a href="#users-updating-users">Updating Users</a> <br /><a href="#users-linking-users">Linking Users</a> <br /><a href="#users-verifying-emails">Verifying Emails</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/users</code></td>
      <td>GET</td>
      <td><a href="#users-querying">Querying Users</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/users/&lt;objectId&gt;</code></td>
      <td>DELETE</td>
      <td><a href="#users-deleting-users">Deleting Users</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/requestPasswordReset</code></td>
      <td>POST</td>
      <td><a href="#users-requesting-a-password-reset">Requesting A Password Reset</a></td>
    </tr>
  </tbody>
</table>

<h2 id="sessions">Sessions</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP Verb</th>
      <th>Functionality</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">/1/sessions</code></td>
      <td>POST</td>
      <td><a href="#sessions-creating-sessions">Creating Restricted Sessions</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/sessions/&lt;objectId&gt;</code></td>
      <td>GET</td>
      <td><a href="#sessions-retrieving-sessions">Retrieving Sessions</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/sessions/me</code></td>
      <td>GET</td>
      <td><a href="#sessions-retrieving-sessions">Retrieving Current Session</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/sessions/&lt;objectId&gt;</code></td>
      <td>PUT</td>
      <td><a href="#sessions-updating-sessions">Updating Sessions</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/sessions</code></td>
      <td>GET</td>
      <td><a href="#sessions-querying-sessions">Querying Sessions</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/sessions/&lt;objectId&gt;</code></td>
      <td>DELETE</td>
      <td><a href="#sessions-deleting-sessions">Deleting Sessions</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/sessions/me</code></td>
      <td>PUT</td>
      <td><a href="#sessions-pairing-session-with-installation">Pairing with Installation</a></td>
    </tr>
  </tbody>
</table>

<h2 id="roles">Roles</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP Verb</th>
      <th>Functionality</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">/1/roles</code></td>
      <td>POST</td>
      <td><a href="#roles-creating-roles">Creating Roles</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/roles/&lt;objectId&gt;</code></td>
      <td>GET</td>
      <td><a href="#roles-retrieving-roles">Retrieving Roles</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/roles/&lt;objectId&gt;</code></td>
      <td>PUT</td>
      <td><a href="#roles-updating-roles">Updating Roles</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/roles/&lt;objectId&gt;</code></td>
      <td>DELETE</td>
      <td><a href="#roles-deleting-roles">Deleting Roles</a></td>
    </tr>
  </tbody>
</table>

<h2 id="files">Files</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP Verb</th>
      <th>Functionality</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">/1/files/&lt;fileName&gt;</code></td>
      <td>POST</td>
      <td><a href="#files-uploading-files">Uploading Files</a></td>
    </tr>
  </tbody>
</table>

<h2 id="analytics">Analytics</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP Verb</th>
      <th>Functionality</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">/1/events/AppOpened</code></td>
      <td>POST</td>
      <td><a href="#analytics-app-open-analytics">Analytics</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/events/&lt;eventName&gt;</code></td>
      <td>POST</td>
      <td><a href="#analytics-custom-analytics">Custom Analytics</a></td>
    </tr>
  </tbody>
</table>

<h2 id="push-notifications">Push Notifications</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP Verb</th>
      <th>Functionality</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">/1/push</code></td>
      <td>POST</td>
      <td><a href="#push-notifications">Push Notifications</a></td>
    </tr>
  </tbody>
</table>

<h2 id="installations">Installations</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP Verb</th>
      <th>Functionality</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">/1/installations</code></td>
      <td>POST</td>
      <td><a href="#push-notifications-uploading-installation-data">Uploading Installation Data</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/installations/&lt;objectId&gt;</code></td>
      <td>GET</td>
      <td><a href="#push-notifications-retrieving-installations">Retrieving Installations</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/installations/&lt;objectId&gt;</code></td>
      <td>PUT</td>
      <td><a href="#push-notifications-updating-installations">Updating Installations</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/installations</code></td>
      <td>GET</td>
      <td><a href="#push-notifications-querying-installations">Querying Installations</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/installations/&lt;objectId&gt;</code></td>
      <td>DELETE</td>
      <td><a href="#push-notifications-deleting-installations">Deleting Installations</a></td>
    </tr>
  </tbody>
</table>

<h2 id="cloud-functions">Cloud Functions</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP Verb</th>
      <th>Functionality</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">/1/functions/&lt;name&gt;</code></td>
      <td>POST</td>
      <td><a href="#cloud-code-cloud-functions">Calling Cloud Functions</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/jobs/&lt;name&gt;</code></td>
      <td>POST</td>
      <td><a href="#cloud-code-background-jobs">Triggering Background Jobs</a></td>
    </tr>
  </tbody>
</table>

<h2 id="schemas">Schemas</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP Verb</th>
      <th>Functionality</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">/1/schemas/</code></td>
      <td>GET</td>
      <td><a href="#schema-fetch-the-schema">Fetch All Schemas</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/schemas/&lt;className&gt;</code></td>
      <td>GET</td>
      <td><a href="#schema-fetch-the-schema">Fetch Schema</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/schemas/&lt;className&gt;</code></td>
      <td>POST</td>
      <td><a href="#schema-adding-a-schema">Create Schema</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/schemas/&lt;className&gt;</code></td>
      <td>PUT</td>
      <td><a href="#schema-modifying-the-schema">Modify Schema</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/schemas/&lt;className&gt;</code></td>
      <td>DELETE</td>
      <td><a href="#schema-removing-a-schema">Delete Schema</a></td>
    </tr>
  </tbody>
</table>

<h2 id="apps">Apps</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP Verb</th>
      <th>Functionality</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">/1/apps/</code></td>
      <td>GET</td>
      <td><a href="#apps-fetching-apps">Fetch Apps</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/apps/&lt;applicationId&gt;</code></td>
      <td>GET</td>
      <td><a href="#apps-fetching-apps">Fetch App</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/apps/&lt;applicationId&gt;</code></td>
      <td>POST</td>
      <td><a href="#apps-creating-apps">Create App</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/apps/&lt;applicationId&gt;</code></td>
      <td>PUT</td>
      <td><a href="#apps-updating-apps">Modify App</a></td>
    </tr>
  </tbody>
</table>

<h2 id="function-hooks">Function Hooks</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP Verb</th>
      <th>Functionality</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">/1/hooks/functions/&lt;functionName&gt;</code></td>
      <td>GET</td>
      <td><a href="#hooks-fetch-functions">Fetch Cloud Functions</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/hooks/functions/</code></td>
      <td>POST</td>
      <td><a href="#hooks-create-function-webhook">Create Cloud Function</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/hooks/functions/&lt;functionName&gt;</code></td>
      <td>PUT</td>
      <td><a href="#hooks-edit-function-webhook">Edit Cloud Function</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/hooks/functions/&lt;functionName&gt;</code></td>
      <td>DELETE</td>
      <td><a href="#hooks-delete-function-webhook">Delete Cloud Function</a></td>
    </tr>
  </tbody>
</table>

<h2 id="trigger-hooks">Trigger Hooks</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP Verb</th>
      <th>Functionality</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">/1/hooks/triggers/&lt;className&gt;/&lt;triggerName&gt;</code></td>
      <td>GET</td>
      <td><a href="#hooks-fetch-triggers">Fetch Cloud Trigger</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/hooks/triggers/</code></td>
      <td>POST</td>
      <td><a href="#hooks-create-trigger-webhook">Create Cloud Trigger</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/hooks/triggers/&lt;className&gt;/&lt;triggerName&gt;</code></td>
      <td>PUT</td>
      <td><a href="#hooks-edit-trigger-webhook">Edit Cloud Trigger</a></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">/1/hooks/triggers/&lt;className&gt;/&lt;triggerName&gt;</code></td>
      <td>DELETE</td>
      <td><a href="#hooks-delete-trigger-webhook">Delete Cloud Trigger</a></td>
    </tr>
  </tbody>
</table>

<h2 id="request-format">Request Format</h2>

<p>For POST and PUT requests, the request body must be JSON, with the <code class="highlighter-rouge">Content-Type</code> header set to <code class="highlighter-rouge">application/json</code>.</p>

<p>Authentication is done via HTTP headers. The <code class="highlighter-rouge">X-Parse-Application-Id</code> header identifies which application you are accessing, and the <code class="highlighter-rouge">X-Parse-REST-API-Key</code> header authenticates the endpoint.</p>

<p>In the examples that follow, the keys for your app are included in the command. You can use the drop-down to construct example code for other apps.</p>

<p>You may also authenticate your REST API requests using basic HTTP authentication. For example, to retrieve an object you could set the URL using your Parse credentials in the following format:</p>

<pre><code class="json">
https://myAppID:javascript-key=myJavaScriptKey@api.parse.com/1/classes/GameScore/Ed1nuqPvcm
</code></pre>

<p>For JavaScript usage, the Parse Cloud supports <a href="http://en.wikipedia.org/wiki/Cross-Origin_Resource_Sharing">cross-origin resource sharing</a>, so that you can use these headers in conjunction with XMLHttpRequest.</p>

<h2 id="response-format">Response Format</h2>

<p>The response format for all requests is a JSON object.</p>

<p>Whether a request succeeded is indicated by the HTTP status code. A 2xx status code indicates success, whereas a 4xx status code indicates failure. When a request fails, the response body is still JSON, but always contains the fields <code class="highlighter-rouge">code</code> and <code class="highlighter-rouge">error</code> which you can inspect to use for debugging. For example, trying to save an object with invalid keys will return the message:</p>

<pre><code class="json">
{
  "code": 105,
  "error": "invalid field name: bl!ng"
}
</code></pre>

<h2 id="calling-from-client-apps">Calling from Client Apps</h2>

<p>You should not use the REST API Key in client apps (i.e. code you distribute to your customers). If the Parse SDK is available for your client platform, we recommend using our SDK instead of the REST API. If you must call the REST API directly from the client, you should use the corresponding client-side Parse key for that plaform (e.g. Client Key for iOS/Android, or .NET Key for Windows/Xamarin/Unity).</p>

<p>If there is no Parse SDK for your client platform, please use your app’s Client Key to call the REST API. Requests made with the Client Key, JavaScript Key, or Windows Key are restricted by client-side app settings that you configure in your Parse.com app dashboard. These settings make your app more secure. For example, we recommend that all production apps turn off the “Client Push Enabled” setting to prevent push notifications from being sent from any device using the Client Key, JavaScript Key, or .NET Key, but not the REST API Key. Therefore, if you plan on registering installations to enable Push Notifications for your app, you should not distribute any app code with the REST API key embedded in it.</p>

<p>The JavaScript Key cannot be used to make requests directly against the REST API from JavaScript. The JavaScript Key is meant to be used with the Parse JavaScript SDK, which makes its posts through a Cross Origin-friendly format without HTTP headers.</p>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="objects">Objects</h1>

<h2 id="object-format">Object Format</h2>

<p>Storing data through the Parse REST API is built around a JSON encoding of the object’s data. This data is schemaless, which means that you don’t need to specify ahead of time what keys exist on each object. You simply set whatever key-value pairs you want, and the backend will store it.</p>

<p>For example, let’s say you’re tracking high scores for a game. A single object could contain:</p>

<pre><code class="json">
{
  "score": 1337,
  "playerName": "Sean Plott",
  "cheatMode": false
}
</code></pre>

<p>Keys must be alphanumeric strings. Values can be anything that can be JSON-encoded.</p>

<p>Each object has a class name that you can use to distinguish different sorts of data. For example, we could call the high score object a <code class="highlighter-rouge">GameScore</code>. We recommend that you NameYourClassesLikeThis and nameYourKeysLikeThis, just to keep your code looking pretty.</p>

<p>When you retrieve objects from Parse, some fields are automatically added: <code class="highlighter-rouge">createdAt</code>, <code class="highlighter-rouge">updatedAt</code>, and <code class="highlighter-rouge">objectId</code>. These field names are reserved, so you cannot set them yourself. The object above could look like this when retrieved:</p>

<pre><code class="json">
{
  "score": 1337,
  "playerName": "Sean Plott",
  "cheatMode": false,
  "createdAt": "2011-08-20T02:06:57.931Z",
  "updatedAt": "2011-08-20T02:06:57.931Z",
  "objectId": "Ed1nuqPvcm"
}
</code></pre>

<p><code class="highlighter-rouge">createdAt</code> and <code class="highlighter-rouge">updatedAt</code> are UTC timestamps stored in ISO 8601 format with millisecond precision: <code class="highlighter-rouge">YYYY-MM-DDTHH:MM:SS.MMMZ</code>. <code class="highlighter-rouge">objectId</code> is a string unique to this class that identifies this object.</p>

<p>In the REST API, the class-level operations operate on a resource based on just the class name. For example, if the class name is <code class="highlighter-rouge">GameScore</code>, the class URL is:</p>

<pre><code class="javascript">
https://api.parse.com/1/classes/GameScore
</code></pre>

<p>Users have a special class-level url:</p>

<pre><code class="javascript">
https://api.parse.com/1/users
</code></pre>

<p>The operations specific to a single object are available a nested URL. For example, operations specific to the <code class="highlighter-rouge">GameScore</code> above with <code class="highlighter-rouge">objectId</code> equal to <code class="highlighter-rouge">Ed1nuqPvcm</code> would use the object URL:</p>

<pre><code class="javascript">
https://api.parse.com/1/classes/GameScore/Ed1nuqPvcm
</code></pre>

<h2 id="creating-objects">Creating Objects</h2>

<p>To create a new object on Parse, send a POST request to the class URL containing the contents of the object. For example, to create the object described above:</p>

<pre><code class="bash">
  curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"score":1337,"playerName":"Sean Plott","cheatMode":false}' \
  https://api.parse.com/1/classes/GameScore
</code></pre>

<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/classes/GameScore', json.dumps({
       "score": 1337,
       "playerName": "Sean Plott",
       "cheatMode": False
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
results = json.loads(connection.getresponse().read())
print results
</code></pre>

<p>When the creation is successful, the HTTP response is a <code class="highlighter-rouge">201 Created</code> and the <code class="highlighter-rouge">Location</code> header contains the object URL for the new object:</p>

<pre><code class="javascript">
Status: 201 Created
Location: https://api.parse.com/1/classes/GameScore/Ed1nuqPvcm
</code></pre>

<p>The response body is a JSON object containing the <code class="highlighter-rouge">objectId</code> and the <code class="highlighter-rouge">createdAt</code> timestamp of the newly-created object:</p>

<pre><code class="json">
{
  "createdAt": "2011-08-20T02:06:57.931Z",
  "objectId": "Ed1nuqPvcm"
}
</code></pre>

<h2 id="retrieving-objects">Retrieving Objects</h2>

<p>Once you’ve created an object, you can retrieve its contents by sending a GET request to the object URL returned in the location header. For example, to retrieve the object we created above:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  https://api.parse.com/1/classes/GameScore/Ed1nuqPvcm
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/classes/GameScore/Ed1nuqPvcm', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The response body is a JSON object containing all the user-provided fields, plus the <code class="highlighter-rouge">createdAt</code>, <code class="highlighter-rouge">updatedAt</code>, and <code class="highlighter-rouge">objectId</code> fields:</p>

<pre><code class="json">
{
  "score": 1337,
  "playerName": "Sean Plott",
  "cheatMode": false,
  "skills": [
    "pwnage",
    "flying"
  ],
  "createdAt": "2011-08-20T02:06:57.931Z",
  "updatedAt": "2011-08-20T02:06:57.931Z",
  "objectId": "Ed1nuqPvcm"
}
</code></pre>

<p>When retrieving objects that have pointers to children, you can fetch child objects by using the <code class="highlighter-rouge">include</code> option. For instance, to fetch the object pointed to by the “game” key:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'include=game' \
  https://api.parse.com/1/classes/GameScore/Ed1nuqPvcm
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"include":"game"})
connection.connect()
connection.request('GET', '/1/classes/GameScore/Ed1nuqPvcm?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="updating-objects">Updating Objects</h2>

<p>To change the data on an object that already exists, send a PUT request to the object URL. Any keys you don’t specify will remain unchanged, so you can update just a subset of the object’s data. For example, if we wanted to change the score field of our object:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"score":73453}' \
  https://api.parse.com/1/classes/GameScore/Ed1nuqPvcm
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/classes/GameScore/Ed1nuqPvcm', json.dumps({
       "score": 73453
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The response body is a JSON object containing just an <code class="highlighter-rouge">updatedAt</code> field with the timestamp of the update.</p>

<pre><code class="json">
{
  "updatedAt": "2011-08-21T18:02:52.248Z"
}
</code></pre>

<h3 id="counters">Counters</h3>

<p>To help with storing counter-type data, Parse provides the ability to atomically increment (or decrement) any number field. So, we can increment the score field like so:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"score":{"__op":"Increment","amount":1}}' \
  https://api.parse.com/1/classes/GameScore/Ed1nuqPvcm
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/classes/GameScore/Ed1nuqPvcm', json.dumps({
       "score": {
         "__op": "Increment",
         "amount": 1
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>To decrement the counter, use the <code class="highlighter-rouge">Increment</code> operator with a negative number:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"score":{"__op":"Increment","amount":-1}}' \
  https://api.parse.com/1/classes/GameScore/Ed1nuqPvcm
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/classes/GameScore/Ed1nuqPvcm', json.dumps({
       "score": {
         "__op": "Increment",
         "amount": -1
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h3 id="arrays">Arrays</h3>

<p>To help with storing array data, there are three operations that can be used to atomically change an array field:</p>

<ul>
  <li><code class="highlighter-rouge">Add</code> appends the given array of objects to the end of an array field.</li>
  <li><code class="highlighter-rouge">AddUnique</code> adds only the given objects which aren’t already contained in an array field to that field. The position of the insert is not guaranteed.</li>
  <li><code class="highlighter-rouge">Remove</code> removes all instances of each given object from an array field.</li>
</ul>

<p>Each method takes an array of objects to add or remove in the “objects” key. For example, we can add items to the set-like “skills” field like so:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"skills":{"__op":"AddUnique","objects":["flying","kungfu"]}}' \
  https://api.parse.com/1/classes/GameScore/Ed1nuqPvcm
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/classes/GameScore/Ed1nuqPvcm', json.dumps({
       "skills": {
         "__op": "AddUnique",
         "objects": [
           "flying",
           "kungfu"
         ]
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h3 id="relations">Relations</h3>

<p>In order to update <code class="highlighter-rouge">Relation</code> types, Parse provides special operators to atomically add and remove objects to a relation.  So, we can add an object to a relation like so:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"opponents":{"__op":"AddRelation","objects":[{"__type":"Pointer","className":"Player","objectId":"Vx4nudeWn"}]}}' \
  https://api.parse.com/1/classes/GameScore/Ed1nuqPvcm
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/classes/GameScore/Ed1nuqPvcm', json.dumps({
       "opponents": {
         "__op": "AddRelation",
         "objects": [
           {
             "__type": "Pointer",
             "className": "Player",
             "objectId": "Vx4nudeWn"
           }
         ]
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>To remove an object from a relation, you can do:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"opponents":{"__op":"RemoveRelation","objects":[{"__type":"Pointer","className":"Player","objectId":"Vx4nudeWn"}]}}' \
  https://api.parse.com/1/classes/GameScore/Ed1nuqPvcm
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/classes/GameScore/Ed1nuqPvcm', json.dumps({
       "opponents": {
         "__op": "RemoveRelation",
         "objects": [
           {
             "__type": "Pointer",
             "className": "Player",
             "objectId": "Vx4nudeWn"
           }
         ]
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="deleting-objects">Deleting Objects</h2>

<p>To delete an object from the Parse Cloud, send a DELETE request to its object URL. For example:</p>

<pre><code class="bash">
curl -X DELETE \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  https://api.parse.com/1/classes/GameScore/Ed1nuqPvcm
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('DELETE', '/1/classes/GameScore/Ed1nuqPvcm', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>You can delete a single field from an object by using the <code class="highlighter-rouge">Delete</code> operation:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"opponents":{"__op":"Delete"}}' \
  https://api.parse.com/1/classes/GameScore/Ed1nuqPvcm
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/classes/GameScore/Ed1nuqPvcm', json.dumps({
       "opponents": {
         "__op": "Delete"
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="batch-operations">Batch Operations</h2>

<p>To reduce the amount of time spent on network round trips, you can create, update, or delete up to 50 objects in one call, using the batch endpoint.</p>

<p>Each command in a batch has <code class="highlighter-rouge">method</code>, <code class="highlighter-rouge">path</code>, and <code class="highlighter-rouge">body</code> parameters that specify the HTTP command that would normally be used for that command. The commands are run in the order they are given. For example, to create a couple of <code class="highlighter-rouge">GameScore</code> objects:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "requests": [
          {
            "method": "POST",
            "path": "/1/classes/GameScore",
            "body": {
              "score": 1337,
              "playerName": "Sean Plott"
            }
          },
          {
            "method": "POST",
            "path": "/1/classes/GameScore",
            "body": {
              "score": 1338,
              "playerName": "ZeroCool"
            }
          }
        ]
      }' \
  https://api.parse.com/1/batch
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/batch', json.dumps({
       "requests": [
         {
           "method": "POST",
           "path": "/1/classes/GameScore",
           "body": {
             "score": 1337,
             "playerName": "Sean Plott"
           }
         },
         {
           "method": "POST",
           "path": "/1/classes/GameScore",
           "body": {
             "score": 1338,
             "playerName": "ZeroCool"
           }
         }
       ]
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The response from batch will be a list with the same number of elements as the input list. Each item in the list with be a dictionary with either the <code class="highlighter-rouge">success</code> or <code class="highlighter-rouge">error</code> field set. The value of <code class="highlighter-rouge">success</code> will be the normal response to the equivalent REST command:</p>

<pre><code class="json">
{
  "success": {
    "createdAt": "2012-06-15T16:59:11.276Z",
    "objectId": "YAfSAWwXbL"
  }
}
</code></pre>

<p>The value of <code class="highlighter-rouge">error</code> will be an object with a numeric <code class="highlighter-rouge">code</code> and <code class="highlighter-rouge">error</code> string:</p>

<pre><code class="json">
{
  "error": {
    "code": 101,
    "error": "object not found for delete"
  }
}
</code></pre>

<p>Other commands that work in a batch are <code class="highlighter-rouge">update</code> and <code class="highlighter-rouge">delete</code>.</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "requests": [
          {
            "method": "PUT",
            "path": "/1/classes/GameScore/Ed1nuqPvcm",
            "body": {
              "score": 999999
            }
          },
          {
            "method": "DELETE",
            "path": "/1/classes/GameScore/Cpl9lrueY5"
          }
        ]
      }' \
  https://api.parse.com/1/batch
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/batch', json.dumps({
       "requests": [
         {
           "method": "PUT",
           "path": "/1/classes/GameScore/Ed1nuqPvcm",
           "body": {
             "score": 999999
           }
         },
         {
           "method": "DELETE",
           "path": "/1/classes/GameScore/Cpl9lrueY5"
         }
       ]
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>Note that N requests sent in a batch will still count toward your request limit as N requests.</p>

<h2 id="data-types">Data Types</h2>

<p>So far we have only used values that can be encoded with standard JSON. The Parse mobile client libraries also support dates, geolocations, and relational data. In the REST API, these values are encoded as JSON hashes with the <code class="highlighter-rouge">__type</code> field set to indicate their type, so you can read or write these fields if you use the correct encoding. Overall, the following types are allowed for each field in your object:</p>

<ul>
  <li>String</li>
  <li>Number</li>
  <li>Boolean</li>
  <li>Arrays</li>
  <li>JSON Objects</li>
  <li>DateTime</li>
  <li>File</li>
  <li>Pointer to another Parse Object</li>
  <li>Relation to another Parse Class</li>
  <li>Null</li>
</ul>

<p>The <code class="highlighter-rouge">Date</code> type contains a field <code class="highlighter-rouge">iso</code> which contains a UTC timestamp stored in ISO 8601 format with millisecond precision: <code class="highlighter-rouge">YYYY-MM-DDTHH:MM:SS.MMMZ</code>.</p>

<pre><code class="json">
{
  "__type": "Date",
  "iso": "2011-08-21T18:02:52.249Z"
}
</code></pre>

<p>Dates are useful in combination with the built-in <code class="highlighter-rouge">createdAt</code> and <code class="highlighter-rouge">updatedAt</code> fields. For example, to retrieve objects created since a particular time, just encode a Date in a comparison query:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"createdAt":{"$gte":{"__type":"Date","iso":"2011-08-21T18:02:52.249Z"}}}' \
  https://api.parse.com/1/classes/GameScore
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "createdAt": {
         "$gte": {
           "__type": "Date",
           "iso": "2011-08-21T18:02:52.249Z"
         }
       }
     })})
connection.connect()
connection.request('GET', '/1/classes/GameScore?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The <code class="highlighter-rouge">Pointer</code> type is used when mobile code sets another Parse <code class="highlighter-rouge">Object</code> as the value of another object. It contains the <code class="highlighter-rouge">className</code> and <code class="highlighter-rouge">objectId</code> of the referred-to value.</p>

<pre><code class="json">
{
  "__type": "Pointer",
  "className": "GameScore",
  "objectId": "Ed1nuqPvc"
}
</code></pre>

<p>Note that the built-in <code class="highlighter-rouge">User</code>, <code class="highlighter-rouge">Role</code>, and <code class="highlighter-rouge">Installation</code> classes are prefixed by an underscore. For example, pointers to user objects have a <code class="highlighter-rouge">className</code> of <code class="highlighter-rouge">_User</code>. Prefixing with an underscore is forbidden for developer-defined classes as it signifies the class is a special built-in.</p>

<p>The <code class="highlighter-rouge">Relation</code> type is used for many-to-many relations. It has a <code class="highlighter-rouge">className</code> that is the class name of the target objects.</p>

<pre><code class="json">
{
  "__type": "Relation",
  "className": "GameScore"
}
</code></pre>

<p>When querying, <code class="highlighter-rouge">Relation</code> objects behave like arrays of Pointers. Any operation that is valid for arrays of pointers (other than <code class="highlighter-rouge">include</code>) works for <code class="highlighter-rouge">Relation</code> objects.</p>

<p>We do not recommend storing large pieces of binary data like images or documents on a Parse object. Parse objects should not exceed 128 kilobytes in size. To store more, we recommend you use <code class="highlighter-rouge">File</code>. You may associate a <a href="#files">previously uploaded file</a> using the <code class="highlighter-rouge">File</code> type.</p>

<pre><code class="json">
{
  "__type": "File",
  "name": "...profile.png"
}
</code></pre>

<p>When more data types are added, they will also be represented as hashes with a <code class="highlighter-rouge">__type</code> field set, so you may not use this field yourself on JSON objects. For more information about how Parse handles data, check out our documentation on <a href="#data">Data</a>.</p>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="queries">Queries</h1>

<h2 id="basic-queries">Basic Queries</h2>

<p>You can retrieve multiple objects at once by sending a GET request to the class URL. Without any URL parameters, this simply lists objects in the class:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  https://api.parse.com/1/classes/GameScore
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/classes/GameScore', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The return value is a JSON object that contains a <code class="highlighter-rouge">results</code> field with a JSON array that lists the objects.</p>

<pre><code class="json">
{
  "results": [
    {
      "playerName": "Jang Min Chul",
      "updatedAt": "2011-08-19T02:24:17.787Z",
      "cheatMode": false,
      "createdAt": "2011-08-19T02:24:17.787Z",
      "objectId": "A22v5zRAgd",
      "score": 80075
    },
    {
      "playerName": "Sean Plott",
      "updatedAt": "2011-08-21T18:02:52.248Z",
      "cheatMode": false,
      "createdAt": "2011-08-20T02:06:57.931Z",
      "objectId": "Ed1nuqPvcm",
      "score": 73453
    }
  ]
}
</code></pre>

<h2 id="query-constraints">Query Constraints</h2>

<p>There are several ways to put constraints on the objects found, using the <code class="highlighter-rouge">where</code> URL parameter. The value of the <code class="highlighter-rouge">where</code> parameter should be encoded JSON. Thus, if you look at the actual URL requested, it would be JSON-encoded, then URL-encoded. The simplest use of the <code class="highlighter-rouge">where</code> parameter is constraining the value for keys. For example, if we wanted to retrieve Sean Plott’s scores that were not in cheat mode, we could do:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"playerName":"Sean Plott","cheatMode":false}' \
  https://api.parse.com/1/classes/GameScore
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "playerName": "Sean Plott",
       "cheatMode": False
     })})
connection.connect()
connection.request('GET', '/1/classes/GameScore?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The values of the <code class="highlighter-rouge">where</code> parameter also support comparisons besides exact matching. Instead of an exact value, provide a hash with keys corresponding to the comparisons to do. The <code class="highlighter-rouge">where</code> parameter supports these options:</p>

<table>
  <thead>
    <tr>
      <th>Key</th>
      <th>Operation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>$lt</td>
      <td>Less Than</td>
    </tr>
    <tr>
      <td>$lte</td>
      <td>Less Than Or Equal To</td>
    </tr>
    <tr>
      <td>$gt</td>
      <td>Greater Than</td>
    </tr>
    <tr>
      <td>$gte</td>
      <td>Greater Than Or Equal To</td>
    </tr>
    <tr>
      <td>$ne</td>
      <td>Not Equal To</td>
    </tr>
    <tr>
      <td>$in</td>
      <td>Contained In</td>
    </tr>
    <tr>
      <td>$nin</td>
      <td>Not Contained in</td>
    </tr>
    <tr>
      <td>$exists</td>
      <td>A value is set for the key</td>
    </tr>
    <tr>
      <td>$select</td>
      <td>This matches a value for a key in the result of a different query</td>
    </tr>
    <tr>
      <td>$dontSelect</td>
      <td>Requires that a key’s value not match a value for a key in the result of a different query</td>
    </tr>
    <tr>
      <td>$all</td>
      <td>Contains all of the given values</td>
    </tr>
    <tr>
      <td>$regex</td>
      <td>Requires that a key’s value match a regular expression</td>
    </tr>
  </tbody>
</table>

<p>For example, to retrieve scores between 1000 and 3000, including the endpoints, we could issue:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"score":{"$gte":1000,"$lte":3000}}' \
  https://api.parse.com/1/classes/GameScore
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "score": {
         "$gte": 1000,
         "$lte": 3000
       }
     })})
connection.connect()
connection.request('GET', '/1/classes/GameScore?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>To retrieve scores equal to an odd number below 10, we could issue:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"score":{"$in":[1,3,5,7,9]}}' \
  https://api.parse.com/1/classes/GameScore
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "score": {
         "$in": [
           1,
           3,
           5,
           7,
           9
         ]
       }
     })})
connection.connect()
connection.request('GET', '/1/classes/GameScore?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>To retrieve scores not by a given list of players we could issue:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={
   "playerName": {
     "$nin": [
       "Jonathan Walsh",
       "Dario Wunsch",
       "Shawn Simon"
     ]
   }
  }' \
  https://api.parse.com/1/classes/GameScore
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "playerName": {
         "$nin": [
           "Jonathan Walsh",
           "Dario Wunsch",
           "Shawn Simon"
         ]
       }
     })})
connection.connect()
connection.request('GET', '/1/classes/GameScore?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>To retrieve documents with the score set, we could issue:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"score":{"$exists":true}}' \
  https://api.parse.com/1/classes/GameScore
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "score": {
         "$exists": True
       }
     })})
connection.connect()
connection.request('GET', '/1/classes/GameScore?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>To retrieve documents without the score set, we could issue:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"score":{"$exists":false}}' \
  https://api.parse.com/1/classes/GameScore
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "score": {
         "$exists": False
       }
     })})
connection.connect()
connection.request('GET', '/1/classes/GameScore?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>If you have a class containing sports teams and you store a user’s hometown in the user class, you can issue one query to find the list of users whose hometown teams have winning records.  The query would look like:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"hometown":{"$select":{"query":{"className":"Team","where":{"winPct":{"$gt":0.5}}},"key":"city"}}}' \
  https://api.parse.com/1/classes/_User
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "hometown": {
         "$select": {
           "query": {
             "className": "Team",
             "where": {
               "winPct": {
                 "$gt": 0.5
               }
             }
           },
           "key": "city"
         }
       }
     })})
connection.connect()
connection.request('GET', '/1/classes/_User?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>In addition to <code class="highlighter-rouge">where</code>, there are several parameters you can use to configure what types of results are returned by the query.</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Use</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>order</td>
      <td>Specify a field to sort by</td>
    </tr>
    <tr>
      <td>limit</td>
      <td>Limit the number of objects returned by the query</td>
    </tr>
    <tr>
      <td>skip</td>
      <td>Use with limit to paginate through results</td>
    </tr>
    <tr>
      <td>keys</td>
      <td>Restrict the fields returned by the query</td>
    </tr>
    <tr>
      <td>include</td>
      <td>Use on Pointer columns to return the full object</td>
    </tr>
  </tbody>
</table>

<p>You can use the <code class="highlighter-rouge">order</code> parameter to specify a field to sort by. Prefixing with a negative sign reverses the order. Thus, to retrieve scores in ascending order:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'order=score' \
  https://api.parse.com/1/classes/GameScore
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"order":"score"})
connection.connect()
connection.request('GET', '/1/classes/GameScore?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>And to retrieve scores in descending order:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'order=-score' \
  https://api.parse.com/1/classes/GameScore
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"order":"-score"})
connection.connect()
connection.request('GET', '/1/classes/GameScore?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>You can sort by multiple fields by passing <code class="highlighter-rouge">order</code> a comma-separated list. To retrieve documents that are ordered by scores in ascending order and the names in descending order:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'order=score,-name' \
  https://api.parse.com/1/classes/GameScore
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"order":"score,-name"})
connection.connect()
connection.request('GET', '/1/classes/GameScore?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>You can use the <code class="highlighter-rouge">limit</code> and <code class="highlighter-rouge">skip</code> parameters for pagination. <code class="highlighter-rouge">limit</code> defaults to 100, but anything from 1 to 1000 is a valid limit. Thus, to retrieve 200 objects after skipping the first 400:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'limit=200' \
  --data-urlencode 'skip=400' \
  https://api.parse.com/1/classes/GameScore
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"limit":200,"skip":400})
connection.connect()
connection.request('GET', '/1/classes/GameScore?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>You can restrict the fields returned by passing <code class="highlighter-rouge">keys</code> a comma-separated list. To retrieve documents that contain only the <code class="highlighter-rouge">score</code> and <code class="highlighter-rouge">playerName</code> fields (and also special built-in fields such as <code class="highlighter-rouge">objectId</code>, <code class="highlighter-rouge">createdAt</code>, and <code class="highlighter-rouge">updatedAt</code>):</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'keys=score,playerName' \
  https://api.parse.com/1/classes/GameScore
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"keys":"score,playerName"})
connection.connect()
connection.request('GET', '/1/classes/GameScore?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>All of these parameters can be used in combination with each other. For example:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={
   "playerName": {
     "$nin": [
       "Jonathan Walsh",
       "Dario Wunsch",
       "Shawn Simon"
     ]
   }
  }' \
  --data-urlencode 'order=score,-name' \
  --data-urlencode 'limit=200' \
  --data-urlencode 'skip=400' \
  --data-urlencode 'keys=score,playerName' \
  https://api.parse.com/1/classes/GameScore
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({
    "where":json.dumps({
      "playerName": {
        "$nin": [
          "Jonathan Walsh",
          "Dario Wunsch",
          "Shawn Simon"
        ]
      }
    }),
    "order":"score,-name",
    "limit":200,
    "skip":400,
    "keys":"score,playerName"})
connection.connect()
connection.request('GET', '/1/classes/GameScore?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="queries-on-array-values">Queries on Array Values</h2>

<p>For keys with an array type, you can find objects where the key’s array value contains 2 by:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"arrayKey":2}' \
  https://api.parse.com/1/classes/RandomObject
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "arrayKey": 2
     })})
connection.connect()
connection.request('GET', '/1/classes/RandomObject?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>You can also use the <code class="highlighter-rouge">$all</code> operator to find objects with an array field which contains each of the values 2, 3, and 4 by:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"arrayKey":{"$all":[2,3,4]}}' \
  https://api.parse.com/1/classes/RandomObject
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "arrayKey": {
         "$all": [
           2,
           3,
           4
         ]
       }
     })})
connection.connect()
connection.request('GET', '/1/classes/RandomObject?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="queries-on-string-values">Queries on String Values</h2>

<div class="tip info"><div>
 If you're trying to implement a generic search feature, we recommend taking a look at this blog post: <a href="http://blog.parse.com/learn/engineering/implementing-scalable-search-on-a-nosql-backend/">Implementing Scalable Search on a NoSQL Backend</a>.
</div></div>

<p>Use the <code class="highlighter-rouge">$regex</code> operator to restrict to string values that match a regular expression. Most regular expression queries in Parse are heavily throttled due to performance considerations. Use case sensitive, anchored queries where possible. Similar to a MySQL LIKE operator, anchored queries are indexed so they are efficient for large datasets. For example:</p>

<pre><code class="bash">
# Finds barbecue sauces that start with "Big Daddy"
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"name":{"$regex":"^Big Daddy"}}' \
  https://api.parse.com/1/classes/BarbecueSauce
</code></pre>
<pre><code class="python">
# Finds barbecue sauces that start with "Big Daddy"
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "name": {
         "$regex": "^Big Daddy"
       }
     })})
connection.connect()
connection.request('GET', '/1/classes/BarbecueSauce?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The above example will match any <code class="highlighter-rouge">BarbecueSauce</code> objects where the value in the “name” String key starts with “Big Daddy”. For example, both “Big Daddy” and “Big Daddy’s” will match, but “big daddy” or “BBQ Sauce: Big Daddy’s” will not.</p>

<p>Queries that have regular expression constraints are very expensive, especially for classes with over 100,000 records. Parse restricts how many such operations can be run on a particular app at any given time.</p>

<h2 id="relational-queries">Relational Queries</h2>

<p>There are several ways to issue queries for relational data. If you want to retrieve objects where a field matches a particular object, you can use a <code class="highlighter-rouge">where</code> clause with a <code class="highlighter-rouge">Pointer</code> encoded with <code class="highlighter-rouge">__type</code> just like you would use other data types. For example, if each <code class="highlighter-rouge">Comment</code> has a <code class="highlighter-rouge">Post</code> object in its <code class="highlighter-rouge">post</code> field, you can fetch comments for a particular <code class="highlighter-rouge">Post</code>:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"post":{"__type":"Pointer","className":"Post","objectId":"8TOXdXf3tz"}}' \
  https://api.parse.com/1/classes/Comment
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "post": {
         "__type": "Pointer",
         "className": "Post",
         "objectId": "8TOXdXf3tz"
       }
     })})
connection.connect()
connection.request('GET', '/1/classes/Comment?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>If you want to retrieve objects where a field contains an object that matches another query, you can use the <code class="highlighter-rouge">$inQuery</code> operator. Note that the default limit of 100 and maximum limit of 1000 apply to the inner query as well, so with large data sets you may need to construct queries carefully to get the desired behavior. For example, imagine you have Post class and a Comment class, where each Comment has a pointer to its parent Post. You can find comments on posts with images by doing:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"post":{"$inQuery":{"where":{"image":{"$exists":true}},"className":"Post"}}}' \
  https://api.parse.com/1/classes/Comment
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "post": {
         "$inQuery": {
           "where": {
             "image": {
               "$exists": True
             }
           },
           "className": "Post"
         }
       }
     })})
connection.connect()
connection.request('GET', '/1/classes/Comment?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>If you want to retrieve objects where a field contains an object that does not match another query, you can use the <code class="highlighter-rouge">$notInQuery</code> operator.  Imagine you have Post class and a Comment class, where each Comment has a pointer to its parent Post.  You can find comments on posts without images by doing:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"post":{"$notInQuery":{"where":{"image":{"$exists":true}},"className":"Post"}}}' \
  https://api.parse.com/1/classes/Comment
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "post": {
         "$notInQuery": {
           "where": {
             "image": {
               "$exists": True
             }
           },
           "className": "Post"
         }
       }
     })})
connection.connect()
connection.request('GET', '/1/classes/Comment?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>If you want to retrieve objects that are members of <code class="highlighter-rouge">Relation</code> field of a parent object, you can use the <code class="highlighter-rouge">$relatedTo</code> operator.  Imagine you have a Post class and User class, where each Post can be liked by many users.  If the Users that liked a Post were stored in a <code class="highlighter-rouge">Relation</code> on the post under the key “likes”, you can find the users that liked a particular post by:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"$relatedTo":{"object":{"__type":"Pointer","className":"Post","objectId":"8TOXdXf3tz"},"key":"likes"}}' \
  https://api.parse.com/1/users
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "$relatedTo": {
         "object": {
           "__type": "Pointer",
           "className": "Post",
           "objectId": "8TOXdXf3tz"
         },
         "key": "likes"
       }
     })})
connection.connect()
connection.request('GET', '/1/users?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>In some situations, you want to return multiple types of related objects in one query. You can do this by passing the field to include in the <code class="highlighter-rouge">include</code> parameter. For example, let’s say you are retrieving the last ten comments, and you want to retrieve their related posts at the same time:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'order=-createdAt' \
  --data-urlencode 'limit=10' \
  --data-urlencode 'include=post' \
  https://api.parse.com/1/classes/Comment
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"order":"-createdAt","limit":10,"include":"post"})
connection.connect()
connection.request('GET', '/1/classes/Comment?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>Instead of being represented as a <code class="highlighter-rouge">Pointer</code>, the <code class="highlighter-rouge">post</code> field is now expanded into the whole object. <code class="highlighter-rouge">__type</code> is set to <code class="highlighter-rouge">Object</code> and <code class="highlighter-rouge">className</code> is provided as well. For example, a <code class="highlighter-rouge">Pointer</code> to a <code class="highlighter-rouge">Post</code> could be represented as:</p>

<pre><code class="json">
{
  "__type": "Pointer",
  "className": "Post",
  "objectId": "8TOXdXf3tz"
}
</code></pre>

<p>When the query is issued with an <code class="highlighter-rouge">include</code> parameter for the key holding this pointer, the pointer will be expanded to:</p>

<pre><code class="json">
{
  "__type": "Object",
  "className": "Post",
  "objectId": "8TOXdXf3tz",
  "createdAt": "2011-12-06T20:59:34.428Z",
  "updatedAt": "2011-12-06T20:59:34.428Z",
  "otherFields": "willAlsoBeIncluded"
}
</code></pre>

<p>You can also do multi level includes using dot notation.  If you wanted to include the post for a comment and the post’s author as well you can do:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'order=-createdAt' \
  --data-urlencode 'limit=10' \
  --data-urlencode 'include=post.author' \
  https://api.parse.com/1/classes/Comment
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"order":"-createdAt","limit":10,"include":"post.author"})
connection.connect()
connection.request('GET', '/1/classes/Comment?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>You can issue a query with multiple fields included by passing a comma-separated list of keys as the <code class="highlighter-rouge">include</code> parameter.</p>

<h2 id="counting-objects">Counting Objects</h2>

<p>Caveat: Count queries are rate limited to a maximum of 160 requests per minute.  They can also return inaccurate results for classes with more than 1,000 objects.  Thus, it is preferable to architect your application to avoid this sort of count operation (by using counters, for example.)</p>

<p>If you are limiting your query, or if there are a very large number of results, and you want to know how many total results there are without returning them all, you can use the <code class="highlighter-rouge">count</code> parameter. For example, if you only care about the number of games played by a particular player:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"playerName":"Jonathan Walsh"}' \
  --data-urlencode 'count=1' \
  --data-urlencode 'limit=0' \
  https://api.parse.com/1/classes/GameScore
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "playerName": "Jonathan Walsh"
     }),"count":1,"limit":0})
connection.connect()
connection.request('GET', '/1/classes/GameScore?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>Since this requests a count as well as limiting to zero results, there will be a count but no results in the response.</p>

<pre><code class="json">
{
  "results": [],
  "count": 1337
}
</code></pre>

<p>With a nonzero limit, that request would return results as well as the count.</p>

<h2 id="compound-queries">Compound Queries</h2>

<p>If you want to find objects that match one of several queries, you can use <code class="highlighter-rouge">$or</code> operator, with a JSONArray as its value.  For instance, if you want to find players with either have a lot of wins or a few wins, you can do:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={"$or":[{"wins":{"$gt":150}},{"wins":{"$lt":5}}]}' \
  https://api.parse.com/1/classes/Player
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "$or": [
         {
           "wins": {
             "$gt": 150
           }
         },
         {
           "wins": {
             "$lt": 5
           }
         }
       ]
     })})
connection.connect()
connection.request('GET', '/1/classes/Player?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>Any other constraints on the query are also applied to the object returned, so you can add other constraints to queries with <code class="highlighter-rouge">$or</code>.</p>

<p>Note that we do not, however, support GeoPoint or non-filtering constraints (e.g. nearSphere, within, limit, skip, sort, include) in the subqueries of the compound query.</p>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="users">Users</h1>

<p>Many apps have a unified login that works across the mobile app and other systems. Accessing user accounts through the REST API lets you build this functionality on top of Parse.</p>

<p>In general, users have the same features as other objects, such as the flexible schema. The differences are that user objects must have a username and password, the password is automatically encrypted and stored securely, and Parse enforces the uniqueness of the <code class="highlighter-rouge">username</code> and <code class="highlighter-rouge">email</code> fields.</p>

<h2 id="signing-up">Signing Up</h2>

<p>Signing up a new user differs from creating a generic object in that the <code class="highlighter-rouge">username</code> and <code class="highlighter-rouge">password</code> fields are required. The password field is handled differently than the others; it is encrypted with bcrypt when stored in the Parse Cloud and never returned to any client request.</p>

<p>You can ask Parse to verify user email addresses in your application settings page. With this setting enabled, all new user registrations with an <code class="highlighter-rouge">email</code> field will generate an email confirmation at that address. You can check whether the user has verified their <code class="highlighter-rouge">email</code> with the <code class="highlighter-rouge">emailVerified</code> field.</p>

<p>To sign up a new user, send a POST request to the users root. You may add any additional fields. For example, to create a user with a specific phone number:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Revocable-Session: 1" \
  -H "Content-Type: application/json" \
  -d '{"username":"cooldude6","password":"p_n7!-e8","phone":"415-392-0202"}' \
  https://api.parse.com/1/users
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/users', json.dumps({
       "username": "cooldude6",
       "password": "p_n7!-e8",
       "phone": "415-392-0202"
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Revocable-Session": "1",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p><code class="highlighter-rouge">The X-Parse-Revocable-Session</code> header tells Parse to return a <a href="#sessions">revocable session</a> even if your app has “Require Revocable Sessions” turned off (at Parse.com app settings page). This is useful for <a href="https://www.parse.com/tutorials/session-migration-tutorial">transitioning from legacy session tokens</a> to revocable sessions when your existing mobile app also accesses the same Parse data. If “Require Revocable Sessions” is turned on (default for new apps), the <code class="highlighter-rouge">X-Parse-Revocable-Session</code> header is unnecessary. When you ask for a revocable session during signup, the Parse Cloud will automatically create a <code class="highlighter-rouge">Session</code> object. On this request, you can also tell Parse to automatically attach an installation to that session by specifying the optional <code class="highlighter-rouge">X-Parse-Installation-Id</code> header with the <code class="highlighter-rouge">installationId</code> of that installation.</p>

<p>When the creation is successful, the HTTP response is a <code class="highlighter-rouge">201 Created</code> and the <code class="highlighter-rouge">Location</code> header contains the URL for the new user:</p>

<pre><code class="javascript">
Status: 201 Created
Location: https://api.parse.com/1/users/g7y9tkhB7O
</code></pre>

<p>The response body is a JSON object containing the <code class="highlighter-rouge">objectId</code>, the <code class="highlighter-rouge">createdAt</code> timestamp of the newly-created object, and the <code class="highlighter-rouge">sessionToken</code> which can be used to authenticate subsequent requests as this user:</p>

<pre><code class="json">
{
  "createdAt": "2011-11-07T20:58:34.448Z",
  "objectId": "g7y9tkhB7O",
  "sessionToken": "r:pnktnjyb996sj4p156gjtp4im"
}
</code></pre>

<h2 id="logging-in">Logging In</h2>

<p>After you allow users to sign up, you need to let them log in to their account with a username and password in the future. To do this, send a GET request to the <code class="highlighter-rouge">/1/login</code> endpoint with <code class="highlighter-rouge">username</code> and <code class="highlighter-rouge">password</code> as URL-encoded parameters:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Revocable-Session: 1" \
  -G \
  --data-urlencode 'username=cooldude6' \
  --data-urlencode 'password=p_n7!-e8' \
  https://api.parse.com/1/login
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"username":"cooldude6","password":"p_n7!-e8"})
connection.connect()
connection.request('GET', '/1/login?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Revocable-Session": "1"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p><code class="highlighter-rouge">The X-Parse-Revocable-Session</code> header tells Parse to return a <a href="#sessions">revocable session</a> even if your app has “Require Revocable Sessions” turned off (at Parse.com app settings page). This is useful for <a href="https://www.parse.com/tutorials/session-migration-tutorial">transitioning from legacy session tokens</a> to revocable sessions when your existing mobile app also accesses the same Parse data. If “Require Revocable Sessions” is turned on (default for new apps), the <code class="highlighter-rouge">X-Parse-Revocable-Session</code> header is unnecessary. When you ask for a revocable session during login, the Parse Cloud will automatically create a <code class="highlighter-rouge">Session</code> object. On this request, you can also tell Parse to automatically attach an installation to that session by specifying the optional <code class="highlighter-rouge">X-Parse-Installation-Id</code> header with the <code class="highlighter-rouge">installationId</code> of that installation.</p>

<p>The response body is a JSON object containing all the user-provided fields except <code class="highlighter-rouge">password</code>. It also contains the <code class="highlighter-rouge">createdAt</code>, <code class="highlighter-rouge">updatedAt</code>, <code class="highlighter-rouge">objectId</code>, and <code class="highlighter-rouge">sessionToken</code> fields:</p>

<pre><code class="json">
{
  "username": "cooldude6",
  "phone": "415-392-0202",
  "createdAt": "2011-11-07T20:58:34.448Z",
  "updatedAt": "2011-11-07T20:58:34.448Z",
  "objectId": "g7y9tkhB7O",
  "sessionToken": "r:pnktnjyb996sj4p156gjtp4im"
}
</code></pre>

<h2 id="verifying-emails">Verifying Emails</h2>

<p>Enabling email verification in an application’s settings allows the application to reserve part of its experience for users with confirmed email addresses. Email verification adds the <code class="highlighter-rouge">emailVerified</code> field to the <code class="highlighter-rouge">User</code> object. When a <code class="highlighter-rouge">User</code>’s <code class="highlighter-rouge">email</code> is set or modified, <code class="highlighter-rouge">emailVerified</code> is set to <code class="highlighter-rouge">false</code>. Parse then emails the user a link which will set <code class="highlighter-rouge">emailVerified</code> to <code class="highlighter-rouge">true</code>.</p>

<p>There are three <code class="highlighter-rouge">emailVerified</code> states to consider:</p>

<ol>
  <li><code class="highlighter-rouge">true</code> - the user confirmed his or her email address by clicking on the link Parse emailed them. <code class="highlighter-rouge">Users</code> can never have a <code class="highlighter-rouge">true</code> value when the user account is first created.</li>
  <li><code class="highlighter-rouge">false</code> - at the time the <code class="highlighter-rouge">User</code> object was last refreshed, the user had not confirmed his or her email address. If <code class="highlighter-rouge">emailVerified</code> is <code class="highlighter-rouge">false</code>, consider refreshing the <code class="highlighter-rouge">User</code> object.</li>
  <li><em>missing</em> - the <code class="highlighter-rouge">User</code> was created when email verification was off or the <code class="highlighter-rouge">User</code> does not have an <code class="highlighter-rouge">email</code>.</li>
</ol>

<h2 id="requesting-a-password-reset">Requesting A Password Reset</h2>

<p>You can initiate password resets for users who have emails associated with their account. To do this, send a POST request to <code class="highlighter-rouge">/1/requestPasswordReset</code> endpoint with <code class="highlighter-rouge">email</code> in the body of the request:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"email":"coolguy@iloveapps.com"}' \
  https://api.parse.com/1/requestPasswordReset
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/requestPasswordReset', json.dumps({
       "email": "coolguy@iloveapps.com"
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>If successful, the response body is an empty JSON object.</p>

<h2 id="retrieving-users">Retrieving Users</h2>

<p>You can also retrieve the contents of a user object by sending a GET request to the URL returned in the location header when it was created. For example, to retrieve the user created above:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  https://api.parse.com/1/users/g7y9tkhB7O
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/users/g7y9tkhB7O', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The response body is a JSON object containing all the user-provided fields except <code class="highlighter-rouge">password</code>. It also contains the <code class="highlighter-rouge">createdAt</code>, <code class="highlighter-rouge">updatedAt</code>, and <code class="highlighter-rouge">objectId</code> fields:</p>

<pre><code class="json">
{
  "username": "cooldude6",
  "phone": "415-392-0202",
  "createdAt": "2011-11-07T20:58:34.448Z",
  "updatedAt": "2011-11-07T20:58:34.448Z",
  "objectId": "g7y9tkhB7O"
}
</code></pre>

<h2 id="validating-session-tokens--retrieving-current-user">Validating Session Tokens / Retrieving Current User</h2>

<p>With a valid session token, you can send a GET request to the <code class="highlighter-rouge">/1/users/me</code> endpoint to retrieve the user associated with that session token:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Session-Token: r:pnktnjyb996sj4p156gjtp4im" \
  https://api.parse.com/1/users/me
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/users/me', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Session-Token": "r:pnktnjyb996sj4p156gjtp4im"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The response matches the JSON object above for retrieving users.  If the session token is not valid, an error object is returned:</p>

<pre><code class="json">
{
  "code": 209,
  "error": "invalid session token"
}
</code></pre>

<h2 id="updating-users">Updating Users</h2>

<p>In normal usage, nobody except the user is allowed to modify their own data. To authenticate themselves, the user must add a <code class="highlighter-rouge">X-Parse-Session-Token</code> header to the request with the session token provided by the signup or login method.</p>

<p>To change the data on a user that already exists, send a PUT request to the user URL. Any keys you don’t specify will remain unchanged, so you can update just a subset of the user’s data. <code class="highlighter-rouge">username</code> and <code class="highlighter-rouge">password</code> may be changed, but the new username must not already be in use.</p>

<p>For example, if we wanted to change the phone number for <code class="highlighter-rouge">cooldude6</code>:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Session-Token: r:pnktnjyb996sj4p156gjtp4im" \
  -H "Content-Type: application/json" \
  -d '{"phone":"415-369-6201"}' \
  https://api.parse.com/1/users/g7y9tkhB7O
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/users/g7y9tkhB7O', json.dumps({
       "phone": "415-369-6201"
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Session-Token": "r:pnktnjyb996sj4p156gjtp4im",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The response body is a JSON object containing just an <code class="highlighter-rouge">updatedAt</code> field with the timestamp of the update.</p>

<pre><code class="json">
{
  "updatedAt": "2011-11-07T21:25:10.623Z"
}
</code></pre>

<h2 id="querying">Querying</h2>

<p>You can retrieve multiple users at once by sending a GET request to the root users URL. Without any URL parameters, this simply lists users:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  https://api.parse.com/1/users
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/users', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The return value is a JSON object that contains a <code class="highlighter-rouge">results</code> field with a JSON array that lists the objects.</p>

<pre><code class="json">
{
  "results": [
    {
      "username": "bigglesworth",
      "phone": "650-253-0000",
      "createdAt": "2011-11-07T20:58:06.445Z",
      "updatedAt": "2011-11-07T20:58:06.445Z",
      "objectId": "3KmCvT7Zsb"
    },
    {
      "username": "cooldude6",
      "phone": "415-369-6201",
      "createdAt": "2011-11-07T20:58:34.448Z",
      "updatedAt": "2011-11-07T21:25:10.623Z",
      "objectId": "g7y9tkhB7O"
    }
  ]
}
</code></pre>

<p>All of the options for queries that work for regular objects also work for user objects, so check the section on <a href="#queries-basic">Querying Objects</a> for more details.</p>

<h2 id="deleting-users">Deleting Users</h2>

<p>To delete a user from the Parse Cloud, send a DELETE request to its URL. You must provide the <code class="highlighter-rouge">X-Parse-Session-Token</code> header to authenticate. For example:</p>

<pre><code class="bash">
curl -X DELETE \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Session-Token: r:pnktnjyb996sj4p156gjtp4im" \
  https://api.parse.com/1/users/g7y9tkhB7O
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('DELETE', '/1/users/g7y9tkhB7O', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Session-Token": "r:pnktnjyb996sj4p156gjtp4im"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="linking-users">Linking Users</h2>

<p>Parse allows you to link your users with services like Twitter and Facebook, enabling your users to sign up or log into your application using their existing identities. This is accomplished through the sign-up and update REST endpoints by providing authentication data for the service you wish to link to a user in the <code class="highlighter-rouge">authData</code> field. Once your user is associated with a service, the <code class="highlighter-rouge">authData</code> for the service will be stored with the user and is retrievable by logging in.</p>

<p><code class="highlighter-rouge">authData</code> is a JSON object with keys for each linked service containing the data below.  In each case, you are responsible for completing the authentication flow (e.g. OAuth 1.0a) to obtain the information the the service requires for linking.</p>

<h3 id="facebook-authdata">Facebook <code class="highlighter-rouge">authData</code></h3>

<pre><code class="json">
{
  "facebook": {
    "id": "user's Facebook id number as a string",
    "access_token": "an authorized Facebook access token for the user",
    "expiration_date": "token expiration date of the format: yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"
  }
}
</code></pre>
<p>Learn more about <a href="https://developers.facebook.com/docs/authentication/">Facebook login</a>.</p>

<h3 id="twitter-authdata">Twitter <code class="highlighter-rouge">authData</code></h3>

<pre><code class="json">
{
  "twitter": {
    "id": "user's Twitter id number as a string",
    "screen_name": "user's Twitter screen name",
    "consumer_key": "your application's consumer key",
    "consumer_secret": "your application's consumer secret",
    "auth_token": "an authorized Twitter token for the user with your application",
    "auth_token_secret": "the secret associated with the auth_token"
  }
}
</code></pre>

<p>Learn more about <a href="https://dev.twitter.com/docs/auth/implementing-sign-twitter">Twitter login</a>.</p>

<h3 id="anonymous-user-authdata">Anonymous user <code class="highlighter-rouge">authData</code></h3>

<pre><code class="json">
{
  "anonymous": {
    "id": "random UUID with lowercase hexadecimal digits"
  }
}
</code></pre>

<h3 id="signing-up-and-logging-in">Signing Up and Logging In</h3>

<p>Signing a user up with a linked service and logging them in with that service uses the same POST request, in which the <code class="highlighter-rouge">authData</code> for the user is specified.  For example, to sign up or log in with a user’s Twitter account:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Revocable-Session: 1" \
  -H "Content-Type: application/json" \
  -d '{
        "authData": {
          "twitter": {
            "id": "12345678",
            "screen_name": "ParseIt",
            "consumer_key": "SaMpLeId3X7eLjjLgWEw",
            "consumer_secret": "SaMpLew55QbMR0vTdtOACfPXa5UdO2THX1JrxZ9s3c",
            "auth_token": "12345678-SaMpLeTuo3m2avZxh5cjJmIrAfx4ZYyamdofM7IjU",
            "auth_token_secret": "SaMpLeEb13SpRzQ4DAIzutEkCE2LBIm2ZQDsP3WUU"
          }
        }
      }' \
  https://api.parse.com/1/users
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/users', json.dumps({
       "authData": {
         "twitter": {
           "id": "12345678",
           "screen_name": "ParseIt",
           "consumer_key": "SaMpLeId3X7eLjjLgWEw",
           "consumer_secret": "SaMpLew55QbMR0vTdtOACfPXa5UdO2THX1JrxZ9s3c",
           "auth_token": "12345678-SaMpLeTuo3m2avZxh5cjJmIrAfx4ZYyamdofM7IjU",
           "auth_token_secret": "SaMpLeEb13SpRzQ4DAIzutEkCE2LBIm2ZQDsP3WUU"
         }
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Revocable-Session": "1",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p><code class="highlighter-rouge">The X-Parse-Revocable-Session</code> header tells Parse to return a <a href="#sessions">revocable session</a> even if your app has “Require Revocable Sessions” turned off (at Parse.com app settings page). This is useful for <a href="https://www.parse.com/tutorials/session-migration-tutorial">transitioning from legacy session tokens</a> to revocable sessions when your existing mobile app also accesses the same Parse data. If “Require Revocable Sessions” is turned on (default for new apps), the <code class="highlighter-rouge">X-Parse-Revocable-Session</code> header is unnecessary. When you ask for a revocable session during login or signup, the Parse Cloud will automatically create a <code class="highlighter-rouge">Session</code> object. On this request, you can also tell Parse to automatically attach an installation to that session by specifying the optional <code class="highlighter-rouge">X-Parse-Installation-Id</code> header with the <code class="highlighter-rouge">installationId</code> of that installation.</p>

<p>Parse then verifies that the provided <code class="highlighter-rouge">authData</code> is valid and checks to see if a user is already associated with this data.  If so, it returns a status code of <code class="highlighter-rouge">200 OK</code> and the details (including a <code class="highlighter-rouge">sessionToken</code> for the user):</p>

<pre><code class="javascript">
Status: 200 OK
Location: https://api.parse.com/1/users/uMz0YZeAqc
</code></pre>

<p>With a response body like:</p>

<pre><code class="json">
{
  "username": "Parse",
  "createdAt": "2012-02-28T23:49:36.353Z",
  "updatedAt": "2012-02-28T23:49:36.353Z",
  "objectId": "uMz0YZeAqc",
  "sessionToken": "r:samplei3l83eerhnln0ecxgy5",
  "authData": {
    "twitter": {
      "id": "12345678",
      "screen_name": "ParseIt",
      "consumer_key": "SaMpLeId3X7eLjjLgWEw",
      "consumer_secret": "SaMpLew55QbMR0vTdtOACfPXa5UdO2THX1JrxZ9s3c",
      "auth_token": "12345678-SaMpLeTuo3m2avZxh5cjJmIrAfx4ZYyamdofM7IjU",
      "auth_token_secret": "SaMpLeEb13SpRzQ4DAIzutEkCE2LBIm2ZQDsP3WUU"
    }
  }
}
</code></pre>

<p>If the user has never been linked with this account, you will instead receive a status code of <code class="highlighter-rouge">201 Created</code>, indicating that a new user was created:</p>

<pre><code class="javascript">
Status: 201 Created
Location: https://api.parse.com/1/users/uMz0YZeAqc
</code></pre>

<p>The body of the response will contain the <code class="highlighter-rouge">objectId</code>, <code class="highlighter-rouge">createdAt</code>, <code class="highlighter-rouge">sessionToken</code>, and an automatically-generated unique <code class="highlighter-rouge">username</code>.  For example:</p>

<pre><code class="json">
{
  "username": "iwz8sna7sug28v4eyu7t89fij",
  "createdAt": "2012-02-28T23:49:36.353Z",
  "objectId": "uMz0YZeAqc",
  "sessionToken": "r:samplei3l83eerhnln0ecxgy5"
}
</code></pre>

<h3 id="linking">Linking</h3>

<p>Linking an existing user with a service like Facebook or Twitter uses a PUT request to associate <code class="highlighter-rouge">authData</code> with the user.  For example, linking a user with a Facebook account would use a request like this:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Session-Token: r:samplei3l83eerhnln0ecxgy5" \
  -H "Content-Type: application/json" \
  -d '{
        "authData": {
          "facebook": {
            "id": "123456789",
            "access_token": "SaMpLeAAibS7Q55FSzcERWIEmzn6rosftAr7pmDME10008bWgyZAmv7mziwfacNOhWkgxDaBf8a2a2FCc9Hbk9wAsqLYZBLR995wxBvSGNoTrEaL",
            "expiration_date": "2012-02-28T23:49:36.353Z"
          }
        }
      }' \
  https://api.parse.com/1/users/uMz0YZeAqc
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/users/uMz0YZeAqc', json.dumps({
       "authData": {
         "facebook": {
           "id": "123456789",
           "access_token": "SaMpLeAAibS7Q55FSzcERWIEmzn6rosftAr7pmDME10008bWgyZAmv7mziwfacNOhWkgxDaBf8a2a2FCc9Hbk9wAsqLYZBLR995wxBvSGNoTrEaL",
           "expiration_date": "2012-02-28T23:49:36.353Z"
         }
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Session-Token": "r:samplei3l83eerhnln0ecxgy5",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>After linking your user to a service, you can authenticate them using matching <code class="highlighter-rouge">authData</code>.</p>

<h3 id="unlinking">Unlinking</h3>

<p>Unlinking an existing user with a service also uses a PUT request to clear <code class="highlighter-rouge">authData</code> from the user by setting the <code class="highlighter-rouge">authData</code> for the service to <code class="highlighter-rouge">null</code>.  For example, unlinking a user with a Facebook account would use a request like this:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Session-Token: r:samplei3l83eerhnln0ecxgy5" \
  -H "Content-Type: application/json" \
  -d '{
        "authData": {
          "facebook": null
        }
      }' \
  https://api.parse.com/1/users/uMz0YZeAqc
</code></pre>
<pre><code class="bash">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/users/uMz0YZeAqc', json.dumps({
       "authData": {
         "facebook": null
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Session-Token": "r:samplei3l83eerhnln0ecxgy5",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="security">Security</h2>

<p>When you access Parse via the REST API key, access can be restricted by ACL just like in the iOS and Android SDKs. You can still read and modify acls via the REST API, just by accessing the <code class="highlighter-rouge">"ACL"</code> key of an object.</p>

<p>The ACL is formatted as a JSON object where the keys are either object ids or the special key <code class="highlighter-rouge">"*"</code> to indicate public access permissions. The values of the ACL are “permission objects”, JSON objects whose keys are the permission names and whose values are always <code class="highlighter-rouge">true</code>.</p>

<p>For example, if you want the user with id <code class="highlighter-rouge">"3KmCvT7Zsb"</code> to have read and write access to an object, plus the object should be publicly readable, that corresponds to an ACL of:</p>

<pre><code class="json">
{
  "3KmCvT7Zsb": {
    "read": true,
    "write": true
  },
  "*": {
    "read": true
  }
}
</code></pre>

<p>If you want to access your data ignoring all ACLs, you can use the master key provided on the Dashboard. Instead of the <code class="highlighter-rouge">X-Parse-REST-API-Key</code> header, set the <code class="highlighter-rouge">X-Parse-Master-Key</code> header. For backward compatibility, you can also do master-level authentication using HTTP Basic Auth, passing the application id as the username and the master key as the password. For security, the master key should not be distributed to end users, but if you are running code in a trusted environment, feel free to use the master key for authentication.</p>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="sessions">Sessions</h1>

<p>Sessions represent an instance of a user logged into a device. Sessions are automatically created when users log in or sign up. They are automatically deleted when users log out. There is one distinct <code class="highlighter-rouge">Session</code> object for each user-installation pair; if a user issues a login request from a device they’re already logged into, that user’s previous <code class="highlighter-rouge">Session</code> object for that Installation is automatically deleted. <code class="highlighter-rouge">Session</code> objects are stored on Parse in the Session class, and you can view them on the Parse.com Data Browser. We provide a set of APIs to manage <code class="highlighter-rouge">Session</code> objects in your app.</p>

<p>A <code class="highlighter-rouge">Session</code> is a subclass of a Parse <code class="highlighter-rouge">Object</code>, so you can query, update, and delete sessions in the same way that you manipulate normal objects on Parse. Because the Parse Cloud automatically creates sessions when you log in or sign up users, you should not manually create <code class="highlighter-rouge">Session</code> objects unless you are building a “Parse for IoT” app (e.g. Arduino or Embedded C). Deleting a <code class="highlighter-rouge">Session</code> will log the user out of the device that is currently using this session’s token.</p>

<p>Unlike other Parse objects, the <code class="highlighter-rouge">Session</code> class does not have Cloud Code triggers. So you cannot register a <code class="highlighter-rouge">beforeSave</code> or <code class="highlighter-rouge">afterSave</code> handler for the Session class.</p>

<h2 id="properties">Properties</h2>

<p>The <code class="highlighter-rouge">Session</code> object has these special fields:</p>

<ul>
  <li><code class="highlighter-rouge">sessionToken</code> (readonly): String token for authentication on Parse API requests. In the response of <code class="highlighter-rouge">Session</code> queries, only your current <code class="highlighter-rouge">Session</code> object will contain a session token.</li>
  <li><code class="highlighter-rouge">user</code>: (readonly) Pointer to the <code class="highlighter-rouge">User</code> object that this session is for.</li>
  <li><code class="highlighter-rouge">createdWith</code> (readonly): Information about how this session was created (e.g. <code class="highlighter-rouge"><span class="p">{</span><span class="w"> </span><span class="nt">"action"</span><span class="p">:</span><span class="w"> </span><span class="s2">"login"</span><span class="p">,</span><span class="w"> </span><span class="nt">"authProvider"</span><span class="p">:</span><span class="w"> </span><span class="s2">"password"</span><span class="p">}</span></code>).
    <ul>
      <li><code class="highlighter-rouge">action</code> could have values: <code class="highlighter-rouge">login</code>, <code class="highlighter-rouge">signup</code>, <code class="highlighter-rouge">create</code>, or <code class="highlighter-rouge">upgrade</code>. The <code class="highlighter-rouge">create</code> action is when the developer manually creates the session by saving a <code class="highlighter-rouge">Session</code> object.  The <code class="highlighter-rouge">upgrade</code> action is when the user is upgraded to revocable session from a legacy session token.</li>
      <li><code class="highlighter-rouge">authProvider</code> could have values: <code class="highlighter-rouge">password</code>, <code class="highlighter-rouge">anonymous</code>, <code class="highlighter-rouge">facebook</code>, or <code class="highlighter-rouge">twitter</code>.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">restricted</code> (readonly): Boolean for whether this session is restricted.
    <ul>
      <li>Restricted sessions do not have write permissions on <code class="highlighter-rouge">User</code>, <code class="highlighter-rouge">Session</code>, and <code class="highlighter-rouge">Role</code> classes on Parse. Restricted sessions also cannot read unrestricted sessions.</li>
      <li>All sessions that the Parse Cloud automatically creates during user login/signup will be unrestricted. All sessions that the developer manually creates by saving a new <code class="highlighter-rouge">Session</code> object from the client (only needed for “Parse for IoT” apps) will be restricted.</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">expiresAt</code> (readonly): Approximate UTC date when this <code class="highlighter-rouge">Session</code> object will be automatically deleted. You can configure session expiration settings (either 1-year inactivity expiration or no expiration) in your app’s Parse.com dashboard settings page.</li>
  <li><code class="highlighter-rouge">installationId</code> (can be set only once): String referring to the <code class="highlighter-rouge">Installation</code> where the session is logged in from. For the REST API, you can set this by passing the <code class="highlighter-rouge">X-Parse-Installation-Id</code> header on login and signup requests.
All special fields except <code class="highlighter-rouge">installationId</code> can only be set automatically by the Parse Cloud. You can add custom fields onto <code class="highlighter-rouge">Session</code> objects, but please keep in mind that any logged-in device (with session token) can read other sessions that belong to the same user (unless you disable Class-Level Permissions, see below).</li>
</ul>

<h2 id="handling-invalid-session-token-error">Handling Invalid Session Token Error</h2>

<p>Apps created before March 25, 2015 use legacy session tokens until you migrate them to use the new revocable sessions. On API requests with legacy tokens, if the token is invalid (e.g. User object was deleted), then the request is executed as a non-logged in user and no error was returned. On API requests with revocable session tokens, an invalid session token will always fail with the “invalid session token” error. This new behavior lets you know when you need to ask the user to log in again.</p>

<p>With revocable sessions, your current session token could become invalid if its corresponding <code class="highlighter-rouge">Session</code> object is deleted from the Parse Cloud. This could happen if you implement a Session Manager UI that lets users log out of other devices, or if you manually delete the session via Cloud Code, REST API, or Data Browser. Sessions could also be deleted due to automatic expiration (if configured in app settings). When a device’s session token no longer corresponds to a <code class="highlighter-rouge">Session</code> object on the Parse Cloud, all API requests from that device will fail with “Error 209: invalid session token”.</p>

<h2 id="creating-sessions">Creating Sessions</h2>

<p>For mobile apps and websites, you should not create <code class="highlighter-rouge">Session</code> objects manually. Instead, you should call <code class="highlighter-rouge">GET /1/login</code> and <code class="highlighter-rouge">POST /1/users</code> (signup), which will automatically generate a <code class="highlighter-rouge">Session</code> object in the Parse Cloud. The session token for this automatically-created session will be sent back on the login and signup response. Same for Facebook/Twitter login and signup requests.</p>

<p>In “Parse for IoT” apps (e.g. Arduino or Embedded C), you may want to programmatically create a restricted session that can be transferred to an IoT device. In order to do this, you must first log in normally to obtain an unrestricted session token. Then, you can create a restricted session by providing this unrestricted session token:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Session-Token: r:pnktnjyb996sj4p156gjtp4im" \
  -H "Content-Type: application/json" \
  -d '{"customField":"value"}' \
  https://api.parse.com/1/sessions
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/sessions', json.dumps({
       "customField": "value"
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Session-Token": "r:pnktnjyb996sj4p156gjtp4im",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>In the above code, <code class="highlighter-rouge">r:pnktnjyb996sj4p156gjtp4im</code> is the unrestricted session token from the original user login.</p>

<p>The response looks like:</p>

<pre><code class="javascript">
{
  "createdAt": "2015-03-25T18:21:52.883Z",
  "createdWith": {
    "action": "create"
  },
  "objectId": "pla1TY9co3",
  "restricted": true,
  "sessionToken": "r:aVrtljyb7E8xKo9256gfvp4n2"
}
</code></pre>

<p>At this point, you can pass the session token <code class="highlighter-rouge">r:aVrtljyb7E8xKo9256gfvp4n2</code> to an IoT device so that it can access the current user’s data.</p>

<h2 id="retrieving-sessions">Retrieving Sessions</h2>

<p>If you have the session’s objectId, you fetch the <code class="highlighter-rouge">Session</code> object as long as it belongs to the same user as your current session:</p>
<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Session-Token: r:pnktnjyb996sj4p156gjtp4im" \
  https://api.parse.com/1/sessions/Axy98kq1B09
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/sessions/Axy98kq1B09', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Session-Token": "r:pnktnjyb996sj4p156gjtp4im"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>If you only have the session’s token (from previous login or session create), you can validate and fetch the corresponding session by:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Session-Token: r:pnktnjyb996sj4p156gjtp4im" \
  https://api.parse.com/1/sessions/me
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/sessions/me', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Session-Token": "r:pnktnjyb996sj4p156gjtp4im"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="updating-sessions">Updating Sessions</h2>

<p>Updating a session is analogous to updating a Parse object.</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Session-Token: r:pnktnjyb996sj4p156gjtp4im" \
  -H "Content-Type: application/json" \
  -d '{"customField":"value"}' \
  https://api.parse.com/1/sessions/Axy98kq1B09
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/logout', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Session-Token": "r:pnktnjyb996sj4p156gjtp4im"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="querying-sessions">Querying Sessions</h2>

<p>Querying for <code class="highlighter-rouge">Session</code> objects will only return objects belonging to the same user as your current session (due to the Session ACL). You can also add a where clause to your query, just like normal Parse objects.</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Session-Token: r:pnktnjyb996sj4p156gjtp4im" \
  https://api.parse.com/1/sessions
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/sessions', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Session-Token": "r:pnktnjyb996sj4p156gjtp4im"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="deleting-sessions">Deleting Sessions</h2>

<p>Deleting the Session object will revoke its session token and cause the user to be logged out on the device that’s currently using this session token. When you have the session token, then you can delete its <code class="highlighter-rouge">Session</code> object by calling the logout endpoint:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Session-Token: r:pnktnjyb996sj4p156gjtp4im" \
  https://api.parse.com/1/logout
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/logout', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Session-Token": "r:pnktnjyb996sj4p156gjtp4im"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>If you want to delete another <code class="highlighter-rouge">Session</code> object for your user, and you have its <code class="highlighter-rouge">objectId</code>, you can delete it (but not log yourself out) by:</p>

<pre><code class="bash">
curl -X DELETE \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Session-Token: r:pnktnjyb996sj4p156gjtp4im" \
  https://api.parse.com/1/sessions/Axy98kq1B09
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('DELETE', '/1/sessions/Axy98kq1B09', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Session-Token": "r:pnktnjyb996sj4p156gjtp4im"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p><code class="highlighter-rouge">X-Parse-Session-Token</code> authenticates the request as the user that also owns session <code class="highlighter-rouge">Axy98kq1B09</code>, which may have a different session token. You can only delete other sessions that belong to the same user.</p>

<h2 id="pairing-session-with-installation">Pairing Session with Installation</h2>

<p>For normal user login with the <code class="highlighter-rouge">/1/login</code> endpoint, the Parse Cloud will set the automatically-created <code class="highlighter-rouge">Session</code> object’s <code class="highlighter-rouge">installationId</code> to the <code class="highlighter-rouge">X-Parse-Installation-Id</code> header passed on the login or signup request. Therefore, for these scenarios, you don’t need to manually associate the <code class="highlighter-rouge">Session</code> object with an installation.</p>

<p>The following API is most useful for “Parse for IoT” apps (e.g. Arduino or Embedded C). During IoT device provisioning, the phone typically does not know the <code class="highlighter-rouge">installationId</code> of the IoT device. The provisioning process typically goes like this:</p>

<ol>
  <li>Phone creates a restricted session (with blank <code class="highlighter-rouge">installationId</code>) for the device.</li>
  <li>IoT device acts as a Wi-Fi software access point. Phone passes this newly-created session’s token, along with the Wi-Fi password, to the IoT device.</li>
  <li>IoT device connects to Internet via Wi-Fi, saves its <code class="highlighter-rouge">Installation</code> object.</li>
  <li>IoT device calls the following endpoint to associate the its <code class="highlighter-rouge">installationId</code> with its session. This endpoint only works with session tokens from restricted sessions. Please note that REST API calls from an IoT device should use the Client Key, not the REST API Key.</li>
</ol>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Client-Key: ${CLIENT_KEY}" \
  -H "X-Parse-Session-Token: r:aVrtljyb7E8xKo9256gfvp4n2" \
  -H "X-Parse-Installation-Id: 2d3777a5-f5fc-4caf-80be-73c766235afb" \
  -H "Content-Type: application/json" \
  -d '{}' \
  https://api.parse.com/1/sessions/me
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/sessions/me', json.dumps({
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Session-Token": "r:aVrtljyb7E8xKo9256gfvp4n2",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="security">Security</h2>

<p><code class="highlighter-rouge">Session</code> objects can only be accessed by the user specified in the user field. All <code class="highlighter-rouge">Session</code> objects have an ACL that is read and write by that user only. You cannot change this ACL. This means querying for sessions will only return objects that match the current logged-in user.</p>

<p>When you log in a user via <code class="highlighter-rouge">/1/login</code>, Parse will automatically create a new unrestricted <code class="highlighter-rouge">Session</code> object in the Parse Cloud. Same for signups and Facebook/Twitter logins.</p>

<p>Session objects manually created from <code class="highlighter-rouge">POST /1/sessions</code> are always restricted. You cannot manually create an unrestricted sessions using the object creation API.</p>

<p>Restricted sessions are prohibited from creating, modifying, or deleting any data in the <code class="highlighter-rouge">User</code>, <code class="highlighter-rouge">Session</code>, and <code class="highlighter-rouge">Role</code> classes. Restricted session also cannot read unrestricted sessions. Restricted Sessions are useful for “Parse for IoT” devices (e.g Arduino or Embedded C) that may run in a less-trusted physical environment than mobile apps. However, please keep in mind that restricted sessions can still read data on <code class="highlighter-rouge">User</code>, <code class="highlighter-rouge">Session</code>, and <code class="highlighter-rouge">Role</code> classes, and can read/write data in any other class just like a normal session. So it is still important for IoT devices to be in a safe physical environment and ideally use encrypted storage to store the session token.</p>

<p>If you want to prevent restricted Sessions from modifying classes other than <code class="highlighter-rouge">User</code>, <code class="highlighter-rouge">Session</code>, or <code class="highlighter-rouge">Role</code>, you can write a Cloud Code <code class="highlighter-rouge">beforeSave</code> handler for that class:</p>

<pre><code class="javascript">
Parse.Cloud.beforeSave("MyClass", function(request, response) {
  Parse.Session.current().then(function(session) {
    if (session.get('restricted')) {
      response.error('write operation not allowed');
    }
    response.success();
  });
});
</code></pre>
<p>You can configure Class-Level Permissions (CLPs) for the Session class just like other classes on Parse. CLPs restrict reading/writing of sessions via the <code class="highlighter-rouge">/1/sessions</code> API, but do not restrict Parse Cloud’s automatic session creation/deletion when users log in, sign up, and log out. We recommend that you disable all CLPs not needed by your app. Here are some common use cases for Session CLPs:</p>

<ul>
  <li><strong>Find</strong>, <strong>Delete</strong> — Useful for building a UI screen that allows users to see their active session on all devices, and log out of sessions on other devices. If your app does not have this feature, you should disable these permissions.</li>
  <li><strong>Create</strong> — Useful for “Parse for IoT” apps (e.g. Arduino or Embedded C) that provision restricted user sessions for other devices from the phone app. You should disable this permission when building apps for mobile and web. For “Parse for IoT” apps, you should check whether your IoT device actually needs to access user-specific data. If not, then your IoT device does not need a user session, and you should disable this permission.</li>
  <li><strong>Get</strong>, <strong>Update</strong>, <strong>Add Field</strong> — Unless you need these operations, you should disable these permissions.</li>
</ul>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="roles">Roles</h1>

<p>As your app grows in scope and user-base, you may find yourself needing more coarse-grained control over access to pieces of your data than user-linked ACLs can provide. To address this requirement, Parse supports a form of <a href="http://en.wikipedia.org/wiki/Role-based_access_control">Role-based Access Control</a>. Roles provide a logical way of grouping users with common access privileges to your Parse data. Roles are named objects that contain users and other roles.  Any permission granted to a role is implicitly granted to its users as well as to the users of any roles that it contains.</p>

<p>For example, in your application with curated content, you may have a number of users that are considered “Moderators” and can modify and delete content created by other users.  You may also have a set of users that are “Administrators” and are allowed all of the same privileges as Moderators, but can also modify the global settings for the application. By adding users to these roles, you can ensure that new users can be made moderators or administrators, without having to manually grant permission to every resource for each user.</p>

<p>We provide a specialized role class to represent these groupings of users for the purposes of assigning permissions.  Roles have a few special fields that set them apart from other objects.</p>

<ul>
  <li>name: The name for the role.  This value is required, and can only be set once as a role is being created. The name must consist of alphanumeric characters, spaces, -, or _.  This name will be used to identify the Role without needing its objectId.</li>
  <li>users: A <a href="#objects-updating">relation</a> to the set of users that will inherit permissions granted to the containing role.</li>
  <li>roles: A <a href="#objects-updating">relation</a> to the set of child roles whose users and roles will inherit permissions granted to the containing role.</li>
</ul>

<p>Often, in order to keep these roles secure, your mobile apps won’t be directly responsible for managing creation and membership of your roles. Instead, roles may be managed by a separate interface on the web or manually managed by an administrator. Our REST API allows you to manage your roles without requiring a mobile client.</p>

<h2 id="creating-roles">Creating Roles</h2>

<p>Creating a new role differs from creating a generic object in that the <code class="highlighter-rouge">name</code> field is required. Roles must also specify an <a href="#users-security"><code class="highlighter-rouge">ACL</code></a>, which should be as restrictive as possible to avoid allowing the wrong users to modify a role.</p>

<p>To create a new role, send a POST request to the roles root:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "name": "Moderators",
        "ACL": {
          "*": {
            "read": true
          }
        }
      }' \
  https://api.parse.com/1/roles
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/roles', json.dumps({
       "name": "Moderators",
       "ACL": {
         "*": {
           "read": True
         }
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>You can create a role with child roles or users by adding existing objects to the <code class="highlighter-rouge">roles</code> and <code class="highlighter-rouge">users</code> <a href="#objects-updating">relations</a>:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "name": "Moderators",
        "ACL": {
          "*": {
            "read": true
          }
        },
        "roles": {
          "__op": "AddRelation",
          "objects": [
            {
              "__type": "Pointer",
              "className": "_Role",
              "objectId": "Ed1nuqPvc"
            }
          ]
        },
        "users": {
          "__op": "AddRelation",
          "objects": [
            {
              "__type": "Pointer",
              "className": "_User",
              "objectId": "8TOXdXf3tz"
            }
          ]
        }
      }' \
  https://api.parse.com/1/roles
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/roles', json.dumps({
       "name": "Moderators",
       "ACL": {
         "*": {
           "read": True
         }
       },
       "roles": {
         "__op": "AddRelation",
         "objects": [
           {
             "__type": "Pointer",
             "className": "_Role",
             "objectId": "Ed1nuqPvc"
           }
         ]
       },
       "users": {
         "__op": "AddRelation",
         "objects": [
           {
             "__type": "Pointer",
             "className": "_User",
             "objectId": "8TOXdXf3tz"
           }
         ]
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>When the creation is successful, the HTTP response is a <code class="highlighter-rouge">201 Created</code> and the Location header contains the object URL for the new object:</p>

<pre><code class="javascript">
Status: 201 Created
Location: https://api.parse.com/1/roles/mrmBZvsErB
</code></pre>

<p>The response body is a JSON object containing the <code class="highlighter-rouge">objectId</code> and <code class="highlighter-rouge">createdAt</code> timestamp of the newly-created object:</p>

<pre><code class="json">
{
  "createdAt": "2012-04-28T17:41:09.106Z",
  "objectId": "mrmBZvsErB"
}
</code></pre>

<h2 id="retrieving-roles">Retrieving Roles</h2>

<p>You can also retrieve the contents of a role object by sending a GET request to the URL returned in the location header when it was created.  For example, to retrieve the role created above:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  https://api.parse.com/1/roles/mrmBZvsErB
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/roles/mrmBZvsErB', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The response body is a JSON object containing all of the fields on the role:</p>

<pre><code class="json">
{
  "createdAt": "2012-04-28T17:41:09.106Z",
  "objectId": "mrmBZvsErB",
  "updatedAt": "2012-04-28T17:41:09.106Z",
  "ACL": {
    "*": {
      "read": true
    },
    "role:Administrators": {
      "write": true
    }
  },
  "name": "Moderators"
}
</code></pre>

<p>Note that the <code class="highlighter-rouge">users</code> and <code class="highlighter-rouge">roles</code> relations will not be visible in this JSON.  Instead, you must <a href="#queries-relational">query</a> for the roles and users that belong to a given role using the <code class="highlighter-rouge">$relatedTo</code> operator.</p>

<h2 id="updating-roles">Updating Roles</h2>

<p>Updating a role generally works like <a href="#objects-updating">updating any other object</a>, but the <code class="highlighter-rouge">name</code> field on the role cannot be changed. Adding and removing users and roles to the <code class="highlighter-rouge">users</code> and <code class="highlighter-rouge">roles</code> relations can be accomplished by using the <code class="highlighter-rouge">AddRelation</code> and <code class="highlighter-rouge">RemoveRelation</code> operators.</p>

<p>For example, we can add two users to the “Moderators” role created above like so:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "users": {
          "__op": "AddRelation",
          "objects": [
            {
              "__type": "Pointer",
              "className": "_User",
              "objectId": "8TOXdXf3tz"
            },
            {
              "__type": "Pointer",
              "className": "_User",
              "objectId": "g7y9tkhB7O"
            }
          ]
        }
      }' \
  https://api.parse.com/1/roles/mrmBZvsErB
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/roles/mrmBZvsErB', json.dumps({
       "users": {
         "__op": "AddRelation",
         "objects": [
           {
             "__type": "Pointer",
             "className": "_User",
             "objectId": "8TOXdXf3tz"
           },
           {
             "__type": "Pointer",
             "className": "_User",
             "objectId": "g7y9tkhB7O"
           }
         ]
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>Similarly, we can remove a child role from the “Moderators” role created above like so:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "roles": {
          "__op": "RemoveRelation",
          "objects": [
            {
              "__type": "Pointer",
              "className": "_Role",
              "objectId": "Ed1nuqPvc"
            }
          ]
        }
      }' \
  https://api.parse.com/1/roles/mrmBZvsErB
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/roles/mrmBZvsErB', json.dumps({
       "roles": {
         "__op": "RemoveRelation",
         "objects": [
           {
             "__type": "Pointer",
             "className": "_Role",
             "objectId": "Ed1nuqPvc"
           }
         ]
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>Note that we’ve included the master key in the query above because the “Moderators” role has an ACL that restricts modification by the public.</p>

<h2 id="deleting-roles">Deleting Roles</h2>

<p>To delete a role from the Parse Cloud, send a DELETE request to its URL.  For example:</p>

<pre><code class="bash">
curl -X DELETE \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  https://api.parse.com/1/roles/mrmBZvsErB
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('DELETE', '/1/roles/mrmBZvsErB', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>Again, we pass the master key in order to bypass the ACL on the role itself.  Alternatively, we could pass an X-Parse-Session-Token for a user that has write access to the Role object (e.g. an Administrator).  For example:</p>

<pre><code class="bash">
curl -X DELETE \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "X-Parse-Session-Token: pnktnjyb996sj4p156gjtp4im" \
  https://api.parse.com/1/roles/mrmBZvsErB
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('DELETE', '/1/roles/mrmBZvsErB', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "X-Parse-Session-Token": "pnktnjyb996sj4p156gjtp4im"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="security">Security</h2>

<p>When you access Parse via the REST API key, access can be restricted by ACL just like in the iOS and Android SDKs.  You can still read and modify ACLs via the REST API, just by accessing the <code class="highlighter-rouge">"ACL"</code> key of an object.
In addition to per-user permissions <a href="#users-security">as described above</a>, you can also specify role-level permissions to your Parse objects. Instead of specifying an <code class="highlighter-rouge">objectId</code> as the key for a permission object as you do for users, you can instead specify a role’s name with a <code class="highlighter-rouge">"role:"</code> prefix as the key for a permission object.  You can use role-level permissions alongside user-level permissions to provide fine-grained control over user access.</p>

<p>For example, to restrict an object to be readable by anyone in the “Members” role and writable by its creator and anyone in the “Moderators” role, you would specify an ACL like this:</p>

<pre><code class="json">
{
  "8TOXdXf3tz": {
    "write": true
  },
  "role:Members": {
    "read": true
  },
  "role:Moderators": {
    "write": true
  }
}
</code></pre>

<p>You are not required to specify read permissions for the user or the “Moderators” role if the user and role are already children of the “Members” role, since they will inherit read permissions granted to “Members”.</p>

<h2 id="role-hierarchy">Role Hierarchy</h2>

<p>As described above, one role can contain another, establishing a parent-child relationship between the two roles. The consequence of this relationship is that any permission granted to the parent role is implicitly granted to all of its child roles.</p>

<p>These types of relationships are commonly found in applications with user-managed content, such as forums. Some small subset of users are “Administrators”, with the highest level of access to tweaking the application’s settings, creating new forums, setting global messages, and so on. Another set of users are “Moderators”, who are responsible for ensuring that the content created by users remains appropriate. Any user with Administrator privileges should also be granted the permissions of any Moderator. To establish this relationship, you would make your “Administrators” role a child role of “Moderators” by adding the “Administrators” role to the <code class="highlighter-rouge">roles</code> relation on your “Moderators” object like this:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "roles": {
          "__op": "AddRelation",
          "objects": [
            {
              "__type": "Pointer",
              "className": "_Role",
              "objectId": "<administratorsroleobjectid>"
            }
          ]
        }
      }' \
  https://api.parse.com/1/roles/<moderatorsroleobjectid>

<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/roles/<moderatorsroleobjectid>', json.dumps({
       "roles": {
         "__op": "AddRelation",
         "objects": [
           {
             "__type": "Pointer",
             "className": "_Role",
             "objectId": "<administratorsroleobjectid>"
           }
         ]
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result

</administratorsroleobjectid></moderatorsroleobjectid></code></pre></moderatorsroleobjectid></administratorsroleobjectid></code></pre>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="files">Files</h1>

<h2 id="uploading-files">Uploading Files</h2>

<p>To upload a file to Parse, send a POST request to the files URL, postfixed with the name of the file. The request must contain the <code class="highlighter-rouge">Content-Type</code> header associated with the file. Keep in mind that files are limited to 10 megabytes. Here’s a simple example that’ll create a file named <code class="highlighter-rouge">hello.txt</code> containing a string:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: text/plain" \
  -d 'Hello, World!' \
  https://api.parse.com/1/files/hello.txt
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/files/hello.txt', 'Hello, World!', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "text/plain"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>When the file upload is successful, the HTTP response is a <code class="highlighter-rouge">201 Created</code> and the <code class="highlighter-rouge">Location</code> header which contains the URL for the file:</p>

<pre><code class="javascript">
Status: 201 Created
Location: http://files.parsetfss.com/bc9f32df-2957-4bb1-93c9-ec47d9870a05/tfss-db295fb2-8a8b-49f3-aad3-dd911142f64f-hello.txt
</code></pre>

<p>The response body is a JSON object containing the <code class="highlighter-rouge">name</code> of the file, which is the original file name prefixed with a unique identifier in order to prevent name collisions. This means you can save files with the same name, and the files will not overwrite one another.</p>

<pre><code class="json">
{
  "url": "http://files.parsetfss.com/bc9f32df-2957-4bb1-93c9-ec47d9870a05/tfss-db295fb2-8a8b-49f3-aad3-dd911142f64f-hello.txt",
  "name": "db295fb2-8a8b-49f3-aad3-dd911142f64f-hello.txt"
}
</code></pre>

<p>To upload an image, the syntax is a little bit different. Here’s an example that will upload the image <code class="highlighter-rouge">myPicture.jpg</code> from the current directory.</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: image/jpeg" \
  --data-binary '@myPicture.jpg' \
  https://api.parse.com/1/files/pic.jpg
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/files/pic.jpg', open('myPicture.jpg', 'rb').read(), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "image/jpeg"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="associating-with-objects">Associating with Objects</h2>

<p>After files are uploaded, you can associate them with Parse objects:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "name": "Andrew",
        "picture": {
          "name": "...profile.png",
          "url": "...profile.png",
          "__type": "File"
        }
      }' \
  https://api.parse.com/1/classes/PlayerProfile
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/classes/PlayerProfile', json.dumps({
       "name": "Andrew",
       "picture": {
         "name": "...profile.png",
         "url:": "...profile.png",
         "__type": "File"
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>Note that the name of the file in the request is not the local file name, but the name in the response of the previous upload operation. It is also important to add the <code class="highlighter-rouge">url</code> from the previous upload operation to the request.</p>

<h2 id="deleting-files">Deleting Files</h2>

<p>Users holding the master key are allowed to delete files using the REST API. To delete a file, send a DELETE request to the files URL, postfixed with the name of the file. Note that the name of the file must be the name in the response of the upload operation, rather than the original filename. Note that the <code class="highlighter-rouge">X-Parse-Master-Key</code> must be provided in headers.</p>

<pre><code class="bash">
curl -X DELETE \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  https://api.parse.com/1/files/...profile.png
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('DELETE', '/1/files/...profile.png', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>Note that deleting a PFObject with a file associated with it will not delete the file. All files stored on Parse should be deleted by using the above explained API.</p>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="geopoints">GeoPoints</h1>

<p>Parse allows you to associate real-world latitude and longitude coordinates with an object.  Adding a <code class="highlighter-rouge">GeoPoint</code> data type to a class allows queries to take into account the proximity of an object to a reference point.  This allows you to easily do things like find out what user is closest to another user or which places are closest to a user.</p>

<h2 id="geopoint">GeoPoint</h2>

<p>To associate a point with an object you will need to embed a <code class="highlighter-rouge">GeoPoint</code> data type into your object.  This is done by using a JSON object with <code class="highlighter-rouge">__type</code> set to the string <code class="highlighter-rouge">GeoPoint</code> and numeric values being set for the <code class="highlighter-rouge">latitude</code> and <code class="highlighter-rouge">longitude</code> keys.  For example, to create an object containing a point under the “location” key with a latitude of 40.0 degrees and -30.0 degrees longitude:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "location": {
          "__type": "GeoPoint",
          "latitude": 40.0,
          "longitude": -30.0
        }
      }' \
  https://api.parse.com/1/classes/PlaceObject
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/classes/PlaceObject', json.dumps({
       "location": {
         "__type": "GeoPoint",
         "latitude": 40.0,
         "longitude": -30.0
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="geo-queries">Geo Queries</h2>

<p>Now that you have a bunch of objects with spatial coordinates, it would be nice to find out which objects are closest to a point.  This can be done by using a <code class="highlighter-rouge">GeoPoint</code> data type with query on the field using <code class="highlighter-rouge">$nearSphere</code>.  Getting a list of ten places that are closest to a user may look something like:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'limit=10' \
  --data-urlencode 'where={
        "location": {
          "$nearSphere": {
            "__type": "GeoPoint",
            "latitude": 30.0,
            "longitude": -20.0
          }
        }
      }' \
  https://api.parse.com/1/classes/PlaceObject
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"limit":10,"where":json.dumps({
       "location": {
         "$nearSphere": {
           "__type": "GeoPoint",
           "latitude": 30.0,
           "longitude": -20.0
         }
       }
     })})
connection.connect()
connection.request('GET', '/1/classes/PlaceObject?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>This will return a list of results ordered by distance from 30.0 latitude and -20.0 longitude. The first result will be the nearest object. (Note that if an explicit <code class="highlighter-rouge">order</code> parameter is supplied, it will take precedence over the distance ordering.) For example, here are two results returned for the above query:</p>

<pre><code class="json">
{
  "results": [
    {
      "location": {
        "latitude": 40.0,
        "__type": "GeoPoint",
        "longitude": -30.0
      },
      "updatedAt": "2011-12-06T22:36:04.983Z",
      "createdAt": "2011-12-06T22:36:04.983Z",
      "objectId": "iFEPN5Gwoz"
    },
    {
      "location": {
        "latitude": 60.0,
        "__type": "GeoPoint",
        "longitude": -20.0
      },
      "updatedAt": "2011-12-06T22:36:26.143Z",
      "createdAt": "2011-12-06T22:36:26.143Z",
      "objectId": "LAyNKSNTHT"
    }
  ]
}
</code></pre>

<p>To limit the search to a maximum distance add a <code class="highlighter-rouge">$maxDistanceInMiles</code> (for miles), <code class="highlighter-rouge">$maxDistanceInKilometers</code> (for kms), or <code class="highlighter-rouge">$maxDistanceInRadians</code> (for radian angle), term to the key constraint.  For example, the following limits the radius to 10 miles:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={
        "location": {
          "$nearSphere": {
            "__type": "GeoPoint",
            "latitude": 30.0,
            "longitude": -20.0
          },
          "$maxDistanceInMiles": 10.0
        }
      }' \
  https://api.parse.com/1/classes/PlaceObject
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "location": {
         "$nearSphere": {
           "__type": "GeoPoint",
           "latitude": 30.0,
           "longitude": -20.0
         },
         "$maxDistanceInMiles": 10.0
       }
     })})
connection.connect()
connection.request('GET', '/1/classes/PlaceObject?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>It’s also possible to query for the set of objects that are contained within a particular area.  To find the objects in a rectangular bounding box, add a clause to the key constraint with the format <code class="highlighter-rouge"><span class="p">{</span><span class="nt">"$within"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">"$box"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="err">[southwestGeoPoint,</span><span class="w"> </span><span class="err">northeastGeoPoint]</span><span class="p">}}}</span></code>.</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -G \
  --data-urlencode 'where={
        "location": {
          "$within": {
            "$box": [
              {
                "__type": "GeoPoint",
                "latitude": 37.71,
                "longitude": -122.53
              },
              {
                "__type": "GeoPoint",
                "latitude": 30.82,
                "longitude": -122.37
              }
            ]
          }
        }
      }' \
  https://api.parse.com/1/classes/PizzaPlaceObject
</code></pre>
<pre><code class="python">
import json,httplib,urllib
connection = httplib.HTTPSConnection('api.parse.com', 443)
params = urllib.urlencode({"where":json.dumps({
       "location": {
         "$within": {
           "$box": [
             {
               "__type": "GeoPoint",
               "latitude": 37.71,
               "longitude": -122.53
             },
             {
               "__type": "GeoPoint",
               "latitude": 30.82,
               "longitude": -122.37
             }
           ]
         }
       }
     })})
connection.connect()
connection.request('GET', '/1/classes/PizzaPlaceObject?%s' % params, '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="caveats">Caveats</h2>

<p>At the moment there are a couple of things to watch out for:</p>

<ol>
  <li>Each PFObject class may only have one key with a PFGeoPoint object.</li>
  <li>Using the <code class="highlighter-rouge">$nearSphere</code> constraint will also limit results to within 100 miles.</li>
  <li>Points should not equal or exceed the extreme ends of the ranges.  Latitude should not be -90.0 or 90.0.  Longitude should not be -180.0 or 180.0.  Attempting to use <code class="highlighter-rouge">GeoPoint</code>’s with latitude and/or longitude outside these ranges will cause an error.</li>
</ol>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="push-notification">Push Notification</h1>

<p>Push Notifications are a great way to keep your users engaged and informed about your app. You can reach your entire user base quickly and effectively. This guide will help you through the setup process and the general usage of Parse to send push notifications.</p>

<p>If you haven’t installed the SDK yet, please <a href="https://github.com/ParsePlatform/parse-server/wiki/Push#quick-start">head over to the Push QuickStart</a> to get our SDK up and running.</p>

<h2 id="installations">Installations</h2>

<h3 id="uploading-installation-data">Uploading Installation Data</h3>

<p>An installation object represents an instance of your app being installed on a device. These objects are used to store subscription data for installations which have subscribed to one or more push notification channels. Installations have a flexible schema, except that the special fields below have special type and validation requirements:</p>

<ul>
  <li><strong><code class="highlighter-rouge">badge</code></strong>: is a number field representing the last known application badge for iOS installations.</li>
  <li><strong><code class="highlighter-rouge">channels</code></strong>: An array of the channels to which a device is currently subscribed.</li>
  <li><strong><code class="highlighter-rouge">timeZone</code></strong>: The current time zone where the target device is located. This should be an <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">IANA time zone identifier</a>.</li>
  <li><strong><code class="highlighter-rouge">deviceType</code></strong>: The type of device, “ios”, “android”, “winrt”, “winphone”, or “dotnet”<em>(readonly)</em>.</li>
  <li><strong><code class="highlighter-rouge">pushType</code></strong>: This field is reserved for directing Parse to the push delivery network to be used. If the device is registered to receive pushes via GCM, this field will be marked “gcm”. If this device is not using GCM, and is using Parse’s push notification service, it will be blank <em>(readonly)</em>.</li>
  <li><strong><code class="highlighter-rouge">GCMSenderId</code></strong>: This field only has meaning for Android installations that use the GCM push type. It is reserved for directing Parse to send pushes to this installation with an alternate GCM sender ID. This field should generally not be set unless you are uploading installation data from another push provider. If you set this field, then you must set the GCM API key corresponding to this GCM sender ID in your Parse application’s push settings.</li>
  <li><strong><code class="highlighter-rouge">installationId</code></strong>: Universally Unique Identifier (UUID) for the device used by Parse. It must be unique across all of an app’s installations. <em>(readonly)</em>.</li>
  <li><strong><code class="highlighter-rouge">deviceToken</code></strong>: The Apple or Google generated token used to deliver messages to the APNs or GCM push networks respectively.</li>
  <li><strong><code class="highlighter-rouge">channelUris</code></strong>: The Microsoft-generated push URIs for Windows devices.</li>
  <li><strong><code class="highlighter-rouge">appName</code></strong>: The display name of the client application to which this installation belongs.</li>
  <li><strong><code class="highlighter-rouge">appVersion</code></strong>: The version string of the client application to which this installation belongs.</li>
  <li><strong><code class="highlighter-rouge">parseVersion</code></strong>: The version of the Parse SDK which this installation uses.</li>
  <li><strong><code class="highlighter-rouge">appIdentifier</code></strong>: A unique identifier for this installation’s client application. In iOS, this is the Bundle Identifier.</li>
</ul>

<p>Most of the time, installation data is modified by push-related methods in the client SDK. For example, calling <code class="highlighter-rouge">subscribeToChannel</code> or <code class="highlighter-rouge">unsubscribeFromChannel</code> from the client SDK will create an object for that installation if it doesn’t yet exist and update its channels, and calling <code class="highlighter-rouge">getSubscribedChannels</code> from the client SDK will read subscription data from that installation’s object. The REST methods can be used to mimic these operations. For instance, if you have an iOS device token then you can subscribe it to push notifications by creating an installation object for it with the desired <code class="highlighter-rouge">channels</code> list. You can also perform operations which aren’t possible through the client SDK, like using a query over installations to find the set of subscribers to a given channel.</p>

<p>Creating an installation object is similar to creating a generic object, but the special installation fields listed above must pass validation. For example, if you have a device token provided by the Apple Push Notification service and would like to subscribe it to the broadcast channel <code class="highlighter-rouge">""</code>, you can use the following command:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "deviceType": "ios",
        "deviceToken": "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
        "channels": [
          ""
        ]
      }' \
  https://api.parse.com/1/installations
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/installations', json.dumps({
       "deviceType": "ios",
       "deviceToken": "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
       "channels": [
         ""
       ]
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>When the creation is successful, the HTTP response is a <code class="highlighter-rouge">201 Created</code> and the <code class="highlighter-rouge">Location</code> header contains the URL for the new installation:</p>

<pre><code class="javascript">
Status: 201 Created
Location: https://api.parse.com/1/installations/mrmBZvsErB
</code></pre>

<p>The response body is a JSON object containing the <code class="highlighter-rouge">objectId</code> and the <code class="highlighter-rouge">createdAt</code> timestamp of the newly-created installation:</p>

<pre><code class="json">
{
  "createdAt": "2012-04-28T17:41:09.106Z",
  "objectId": "mrmBZvsErB"
}
</code></pre>

<p>When creating Android installation objects containing GCM (Google Cloud Messaging) credentials, you must have at least the following fields in your installation object:</p>

<ul>
  <li>A <code class="highlighter-rouge">deviceType</code> set to <code class="highlighter-rouge">android</code>.</li>
  <li>A <code class="highlighter-rouge">pushType</code> set to <code class="highlighter-rouge">gcm</code>.</li>
  <li>A GCM registration ID in the <code class="highlighter-rouge">deviceToken</code> field.</li>
  <li>The GCM sender ID associated with this registration ID in the <code class="highlighter-rouge">GCMSenderId</code> field.</li>
</ul>

<p>You could create and object with these fields using a command like this:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "deviceType": "android",
        "pushType": "gcm",
        "deviceToken": "APA91bFMvbrGg4cp3KUV_7dhU1gmwE_...",
        "GCMSenderId": "56712320625545",
        "channels": [
          ""
        ]
      }' \
  https://api.parse.com/1/installations
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/installations', json.dumps({
       "deviceType": "android",
       "pushType": "gcm",
       "deviceToken": "APA91bFMvbrGg4cp3KUV_7dhU1gmwE_...",
       "GCMSenderId": "56712320625545",
       "channels": [
         ""
       ]
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>If you upload Android installations with GCM credentials, then you must also set the GCM API Key associated with this GCM sender ID in your application’s push settings.</p>

<h3 id="retrieving-installations">Retrieving Installations</h3>

<p>You can retrieve the contents of an installation object by sending a GET request to the URL returned in the location header when it was created. For example, to retrieve the installation created above:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  https://api.parse.com/1/installations/mrmBZvsErB
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/installations/mrmBZvsErB', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The response body is a JSON object containing all the user-provided fields, plus the <code class="highlighter-rouge">createdAt</code>, <code class="highlighter-rouge">updatedAt</code>, and <code class="highlighter-rouge">objectId</code> fields:</p>

<pre><code class="json">
{
  "deviceType": "ios",
  "deviceToken": "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
  "channels": [
    ""
  ],
  "createdAt": "2012-04-28T17:41:09.106Z",
  "updatedAt": "2012-04-28T17:41:09.106Z",
  "objectId": "mrmBZvsErB"
}
</code></pre>

<h3 id="updating-installations">Updating Installations</h3>

<p>Installation objects can be updated by sending a PUT request to the installation URL. For example, to subscribe the installation above to the “foo” push channel:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "deviceType": "ios",
        "deviceToken": "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
        "channels": [
          "",
          "foo"
        ]
      }' \
  https://api.parse.com/1/installations/mrmBZvsErB
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/installations/mrmBZvsErB', json.dumps({
       "deviceType": "ios",
       "deviceToken": "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
       "channels": [
         "",
         "foo"
       ]
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>Note that there is a restriction on updating the <code class="highlighter-rouge">deviceToken</code> field of Installation objects. You can only update the <code class="highlighter-rouge">deviceToken</code> field of an Installation object if contains a non-nil <code class="highlighter-rouge">installationId</code> field.</p>

<h3 id="querying-installations">Querying Installations</h3>

<p>You can retrieve multiple installations at once by sending a GET request to the root installations URL. This functionality is not available in the SDKs, so you must authenticate this method using the <code class="highlighter-rouge">X-Parse-Master-Key</code> header in your request instead of the <code class="highlighter-rouge">X-Parse-REST-API-Key</code> header. Your master key allows you to bypass ACLs and should only be used from within a trusted environment.</p>

<p>Without any URL parameters, a GET request simply lists installations:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  https://api.parse.com/1/installations
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/installations', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The return value is a JSON object that contains a results field with a JSON array that lists the users.</p>

<pre><code class="json">
{
  "results": [
    {
      "deviceType": "ios",
      "deviceToken": "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
      "channels": [
        ""
      ],
      "createdAt": "2012-04-28T17:41:09.106Z",
      "updatedAt": "2012-04-28T17:41:09.106Z",
      "objectId": "mrmBZvsErB"
    },
    {
      "deviceType": "ios",
      "deviceToken": "fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210",
      "channels": [
        ""
      ],
      "createdAt": "2012-04-30T01:52:57.975Z",
      "updatedAt": "2012-04-30T01:52:57.975Z",
      "objectId": "sGlvypFQcO"
    }
  ]
}
</code></pre>

<p>All of the options for queries that work for regular objects also work for installation objects, so check the section on <a href="#queries-basic-queries">Querying Objects</a> for more details. By doing an array query over <code class="highlighter-rouge">channels</code>, for example, you can find the set of devices subscribed to a given push channel.</p>

<h3 id="deleting-installations">Deleting Installations</h3>

<p>To delete an installation from the Parse Cloud, send a DELETE request to its URL. This functionality is not available in the client SDKs, so you must authenticate this method using the <code class="highlighter-rouge">X-Parse-Master-Key</code> header in your request instead of the <code class="highlighter-rouge">X-Parse-REST-API-Key</code> header. Your master key allows you to bypass ACLs and should only be used from within a trusted environment. For example:</p>

<pre><code class="bash">
curl -X DELETE \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  https://api.parse.com/1/installations/mrmBZvsErB
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('DELETE', '/1/installations/mrmBZvsErB', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="sending-pushes">Sending Pushes</h2>

<p>There are two ways to send push notifications using Parse: <a href="#push-notifications-using-channels">channels</a> and <a href="#push-notifications-using-advanced-targeting">advanced targeting</a>. Channels offer a simple and easy to use model for sending pushes, while advanced targeting offers a more powerful and flexible model. Both are fully compatible with each other and will be covered in this section.</p>

<p>You can view your past push notifications on the Parse.com push console for up to 30 days after creating your push.  For pushes scheduled in the future, you can delete the push on the push console as long as no sends have happened yet. After you send the push, the push console shows push analytics graphs.</p>

<h3 id="using-channels">Using Channels</h3>

<p>The simplest way to start sending notifications is using channels. This allows you to use a publisher-subscriber model for sending pushes. Devices start by subscribing to one or more channels, and notifications can later be sent to these subscribers. The channels subscribed to by a given <code class="highlighter-rouge">Installation</code> are stored in the <code class="highlighter-rouge">channels</code> field of the <code class="highlighter-rouge">Installation</code> object.</p>

<h4 id="subscribing-to-channels">Subscribing to Channels</h4>

<p>A channel is identified by a string that starts with a letter and consists of alphanumeric characters, underscores, and dashes. It doesn’t need to be explicitly created before it can be used and each <code class="highlighter-rouge">Installation</code> can subscribe to any number of channels at a time.</p>

<p>Subscribing to a channel via the REST API can be done by updating the <code class="highlighter-rouge">Installation</code> object. We send a PUT request to the <code class="highlighter-rouge">Installation</code> URL and update the <code class="highlighter-rouge">channels</code> field. For example, in a baseball score app, we could do:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "channels": [
          "Giants"
        ]
      }' \
  https://api.parse.com/1/installations/mrmBZvsErB
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/installations/mrmBZvsErB', json.dumps({
       "channels": [
         "Giants"
       ]
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>Once subscribed to the “Giants” channel, your <code class="highlighter-rouge">Installation</code> object should have an updated <code class="highlighter-rouge">channels</code> field.</p>

<p><img src="/docs/assets/images/installation_channel.png" alt="" /></p>

<p>To unsubscribe from a channel you would need to update the <code class="highlighter-rouge">channels</code> array and remove the unsubscribed channel.</p>

<h4 id="sending-pushes-to-channels">Sending Pushes to Channels</h4>

<p>With the REST API, the following code can be used to alert all subscribers of the “Giants” and “Mets” channels about the results of the game. This will display a notification center alert to iOS users and a system tray notification to Android users.</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "channels": [
          "Giants",
          "Mets"
        ],
        "data": {
          "alert": "The Giants won against the Mets 2-3."
        }
      }' \
  https://api.parse.com/1/push
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/push', json.dumps({
       "channels": [
         "Giants",
         "Mets"
       ],
       "data": {
         "alert": "The Giants won against the Mets 2-3."
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h3 id="using-advanced-targeting">Using Advanced Targeting</h3>

<p>While channels are great for many applications, sometimes you need more precision when targeting the recipients of your pushes. Parse allows you to write a query for any subset of your <code class="highlighter-rouge">Installation</code> objects using the <a href="#queries">querying API</a> and to send them a push.</p>

<p>Since <code class="highlighter-rouge">Installation</code> objects are just like any other object stored in Parse, you can save any data you want and even create relationships between <code class="highlighter-rouge">Installation</code> objects and your other objects. This allows you to send pushes to a very customized and dynamic segment of your user base.</p>

<h4 id="saving-installation-data">Saving Installation Data</h4>

<p>Storing arbitrary data on an <code class="highlighter-rouge">Installation</code> object is done in the same way we store data on <a href="#objects">any other object</a> on Parse. In our Baseball app, we could allow users to get pushes about game results, scores and injury reports.</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "scores": true,
        "gameResults": true,
        "injuryReports": true
      }' \
  https://api.parse.com/1/installations/mrmBZvsErB
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/installations/mrmBZvsErB', json.dumps({
       "scores": True,
       "gameResults": True,
       "injuryReports": True
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>You can even create relationships between your <code class="highlighter-rouge">Installation</code> objects and other classes saved on Parse. To associate an Installation with a particular user, for example, you can use a pointer to the <code class="highlighter-rouge">_User</code> class on the <code class="highlighter-rouge">Installation</code>.</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "user": {
          "__type": "Pointer",
          "className": "_User",
          "objectId": "vmRZXZ1Dvo"
        }
      }' \
  https://api.parse.com/1/installations/mrmBZvsErB
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/installations/mrmBZvsErB', json.dumps({
       "user": {
         "__type": "Pointer",
         "className": "_User",
         "objectId": "vmRZXZ1Dvo"
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h4 id="sending-pushes-to-queries">Sending Pushes to Queries</h4>

<p>Once you have your data stored on your <code class="highlighter-rouge">Installation</code> objects, you can use a query to target a subset of these devices. <code class="highlighter-rouge">Installation</code> queries work just like any other <a href="#queries">Parse query</a>.</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "where": {
          "injuryReports": true
        },
        "data": {
          "alert": "Willie Hayes injured by own pop fly."
        }
      }' \
  https://api.parse.com/1/push
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/push', json.dumps({
       "where": {
         "injuryReports": True
       },
       "data": {
         "alert": "Willie Hayes injured by own pop fly."
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>We can even use channels with our query. To send a push to all subscribers of the “Giants” channel but filtered by those who want score update, we can do the following:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "where": {
          "channels": "Giants",
          "scores": true
        },
        "data": {
          "alert": "The Giants scored a run! The score is now 2-2."
        }
      }' \
  https://api.parse.com/1/push
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/push', json.dumps({
       "where": {
         "channels": "Giants",
         "scores": True
       },
       "data": {
         "alert": "The Giants scored a run! The score is now 2-2."
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>If we store relationships to other objects in our <code class="highlighter-rouge">Installation</code> class, we can also use those in our query. For example, we could send a push notification to all users near a given location like this.</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "where": {
          "user": {
            "$inQuery": {
              "location": {
                "$nearSphere": {
                  "__type": "GeoPoint",
                  "latitude": 30.0,
                  "longitude": -20.0
                },
                "$maxDistanceInMiles": 1.0
              }
            }
          }
        },
        "data": {
          "alert": "Free hotdogs at the Parse concession stand!"
        }
      }' \
  https://api.parse.com/1/push
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/push', json.dumps({
       "where": {
         "user": {
           "$inQuery": {
             "location": {
               "$nearSphere": {
                 "__type": "GeoPoint",
                 "latitude": 30.0,
                 "longitude": -20.0
               },
               "$maxDistanceInMiles": 1.0
             }
           }
         }
       },
       "data": {
         "alert": "Free hotdogs at the Parse concession stand!"
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>An in depth look at the <code class="highlighter-rouge">Installation</code> end point can be found in the <a href="#push-notifications-installations">REST guide</a>.</p>

<h2 id="sending-options">Sending Options</h2>

<p>Push notifications can do more than just send a message. In iOS, pushes can also include the sound to be played, the badge number to display as well as any custom data you wish to send. In Android, it is even possible to specify an <code class="highlighter-rouge">Intent</code> to be fired upon receipt of a notification. An expiration date can also be set for the notification in case it is time sensitive.</p>

<h3 id="customizing-your-notifications">Customizing your Notifications</h3>

<p>If you want to send more than just a message, you can set other fields in the <code class="highlighter-rouge">data</code> dictionary. There are some reserved fields that have a special meaning.</p>

<ul>
  <li><strong><code class="highlighter-rouge">alert</code></strong>: the notification’s message.</li>
  <li><strong><code class="highlighter-rouge">badge</code></strong>: <em>(iOS only)</em> the value indicated in the top right corner of the app icon. This can be set to a value or to <code class="highlighter-rouge">Increment</code> in order to increment the current value by 1.</li>
  <li><strong><code class="highlighter-rouge">sound</code></strong>: <em>(iOS only)</em> the name of a sound file in the application bundle.</li>
  <li><strong><code class="highlighter-rouge">content-available</code></strong>: <em>(iOS only)</em> If you are a writing a <a href="http://developer.apple.com/library/iOS/#technotes/tn2280/_index.html">Newsstand</a> app, or an app using the Remote Notification Background Mode <a href="https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS7.html#//apple_ref/doc/uid/TP40013162-SW10">introduced in iOS7</a> (a.k.a. “Background Push”), set this value to 1 to trigger a background download.</li>
  <li><strong><code class="highlighter-rouge">category</code></strong>: <em>(iOS only)</em> the identifier of the <a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIUserNotificationCategory_class/index.html#//apple_ref/occ/cl/UIUserNotificationCategory"><code class="highlighter-rouge">UIUserNotificationCategory</code></a> for this push notification.</li>
  <li><strong><code class="highlighter-rouge">uri</code></strong>: <em>(Android only)</em> an optional field that contains a URI. When the notification is opened, an <code class="highlighter-rouge">Activity</code> associated      with opening the URI is launched.</li>
  <li><strong><code class="highlighter-rouge">title</code></strong>: <em>(Android only)</em> the value displayed in the Android system tray notification.</li>
</ul>

<p>For example, to send a notification that increases the current badge number by 1 and plays a custom sound for iOS devices, and displays a particular title for Android users, you can do the following:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "channels": [
          "Mets"
        ],
        "data": {
          "alert": "The Mets scored! The game is now tied 1-1.",
          "badge": "Increment",
          "sound": "cheering.caf",
          "title": "Mets Score!"
        }
      }' \
  https://api.parse.com/1/push
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/push', json.dumps({
       "channels": [
         "Mets"
       ],
       "data": {
         "alert": "The Mets scored! The game is now tied 1-1.",
         "badge": "Increment",
         "sound": "cheering.caf",
         "title": "Mets Score!"
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>It is also possible to specify your own data in this dictionary. As explained in the Receiving Notifications section for <a href="/docs/ios/guide#push-notifications-receiving-pushes">iOS</a> and <a href="/docs/android/guide#push-notifications-receiving-pushes">Android</a>, iOS will give you access to this data only when the user opens your app via the notification and Android will provide you this data in the <code class="highlighter-rouge">Intent</code> if one is specified.</p>

<pre><code class="bash">
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/push', json.dumps({
       "channels": [
         "Indians"
       ],
       "data": {
         "action": "com.example.UPDATE_STATUS",
         "alert": "Ricky Vaughn was injured during the game last night!",
         "name": "Vaughn",
         "newsItem": "Man bites dog"
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h3 id="setting-an-expiration-date">Setting an Expiration Date</h3>

<p>When a user’s device is turned off or not connected to the internet, push notifications cannot be delivered. If you have a time sensitive notification that is not worth delivering late, you can set an expiration date. This avoids needlessly alerting users of information that may no longer be relevant.</p>

<p>There are two parameters provided by Parse to allow setting an expiration date for your notification. The first is <code class="highlighter-rouge">expiration_time</code> which takes a date (in ISO 8601 format or Unix epoch time) specifying when Parse should stop trying to send the notification. To expire the notification exactly 1 week from now, you can use the following command.</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "expiration_time": "2015-03-19T22:05:08Z",
        "data": {
          "alert": "Season tickets on sale until March 19, 2015"
        }
      }' \
  https://api.parse.com/1/push
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/push', json.dumps({
       "expiration_time": "2015-03-19T22:05:08Z",
       "data": {
         "alert": "Season tickets on sale until March 19, 2015"
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>Alternatively, you can use the <code class="highlighter-rouge">expiration_interval</code> parameter to specify a duration of time before your notification expired. This value is relative to the <code class="highlighter-rouge">push_time</code> parameter used to <a href="#push-notifications-scheduling-pushes">schedule notifications</a>. This means that a push notification scheduled to be sent out in 1 day and an expiration interval of 6 days can be received up to a week from March 16th, 2015.</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "push_time": "2015-03-13T22:05:08Z",
        "expiration_interval": 518400,
        "data": {
          "alert": "Season tickets on sale until March 19, 2015"
        }
      }' \
  https://api.parse.com/1/push
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/push', json.dumps({
       "push_time": "2015-03-13T22:05:08Z",
       "expiration_interval": 518400,
       "data": {
         "alert": "Season tickets on sale until March 19, 2015"
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>
<p>### Targeting by Platform</p>

<p>If you build a cross platform app, it is possible you may only want to target iOS or Android devices. There are two methods provided to filter which of these devices are targeted. Note that both platforms are targeted by default.</p>

<p>The following examples would send a different notification to Android, iOS, and Windows users.</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "where": {
          "deviceType": "android"
        },
        "data": {
          "alert": "Your suitcase has been filled with tiny robots!"
        }
      }' \
  https://api.parse.com/1/push
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/push', json.dumps({
       "where": {
         "deviceType": "android"
       },
       "data": {
         "alert": "Your suitcase has been filled with tiny robots!"
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "where": {
          "deviceType": "ios"
        },
        "data": {
          "alert": "Your suitcase has been filled with tiny apples!"
        }
      }' \
  https://api.parse.com/1/push
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/push', json.dumps({
       "where": {
         "deviceType": "ios"
       },
       "data": {
         "alert": "Your suitcase has been filled with tiny apples!"
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "where": {
          "deviceType": "winrt"
        },
        "data": {
          "alert": "Your suitcase has been filled with tiny glass!"
        }
      }' \
  https://api.parse.com/1/push
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/push', json.dumps({
       "where": {
         "deviceType": "winrt"
       },
       "data": {
         "alert": "Your suitcase has been filled with tiny glass!"
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "where": {
          "deviceType": "winphone"
        },
        "data": {
          "alert": "Your suitcase is very hip; very metro."
        }
      }' \
  https://api.parse.com/1/push
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/push', json.dumps({
       "where": {
         "deviceType": "winphone"
       },
       "data": {
         "alert": "Your suitcase is very hip; very metro."
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="scheduling-pushes">Scheduling Pushes</h2>

<p>You can schedule a push in advance by specifying a <code class="highlighter-rouge">push_time</code>. For example, if a user schedules a game reminder for a game on March 19th, 2015 at noon UTC, you can schedule the push notification by sending:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "where": {
          "user_id": "user_123"
        },
        "push_time": "2015-03-19T12:00:00Z",
        "data": {
          "alert": "You previously created a reminder for the game today"
        }
      }' \
  https://api.parse.com/1/push
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/push', json.dumps({
       "where": {
         "user_id": "user_123"
       },
       "push_time": "2015-03-19T12:00:00Z",
       "data": {
         "alert": "You previously created a reminder for the game today"
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>If you also specify an <code class="highlighter-rouge">expiration_interval</code>, it will be calculated from the scheduled push time, not from the time the push is submitted. This means a push scheduled to be sent in a week with an expiration interval of a day will expire 8 days after the request is sent.</p>

<p>The scheduled time cannot be in the past, and can be up to two weeks in the future. It can be an ISO 8601 date with a date, time, and timezone, as in the example above, or it can be a numeric value representing a UNIX epoch time in seconds (UTC). To schedule an alert for 08/22/2015 at noon UTC time, you can set the <code class="highlighter-rouge">push_time</code> to either <code class="highlighter-rouge">2015-08-022T12:00:00.000Z</code> or <code class="highlighter-rouge">1440226800000</code>.</p>

<h3 id="local-push-scheduling">Local Push Scheduling</h3>

<p>The <code class="highlighter-rouge">push_time</code> parameter can schedule a push to be delivered to each device according to its time zone. This technique delivers a push to all <code class="highlighter-rouge">Installation</code> objects with a <code class="highlighter-rouge">timeZone</code> member when that time zone would match the push time. For example, if an app had a device in timezone <code class="highlighter-rouge">America/New_York</code> and another in <code class="highlighter-rouge">America/Los_Angeles</code>, the first would receive the push three hours before the latter.</p>

<p>To schedule a push according to each device’s local time, the <code class="highlighter-rouge">push_time</code> parameter should be an ISO 8601 date without a time zone, i.e. <code class="highlighter-rouge">2015-03-19T12:00:00</code>. Note that Installations without a <code class="highlighter-rouge">timeZone</code> will be excluded from this localized push.</p>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="config">Config</h1>

<p><code class="highlighter-rouge">Parse Config</code> is a way to configure your applications remotely by storing a single configuration object on Parse. It enables you to add things like feature gating or a simple “Message of the day”. To start using <code class="highlighter-rouge">Parse Config</code> you need to add a few key/value pairs (parameters) to your app on the Parse Config Dashboard.</p>

<p><img src="/docs/assets/images/config_editor.png" alt="" /></p>

<p>After that you will be able to fetch the config on the client by sending a <code class="highlighter-rouge">GET</code> request to config URL. Here is a simple example that will fetch the <code class="highlighter-rouge">Parse.Config</code>:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  https://api.parse.com/1/config
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/config', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The response body is a JSON object containing all the configuration parameters in the <code class="highlighter-rouge">params</code> field.</p>

<pre><code class="json">
{
  "params": {
    "welcomeMessage": "Welcome to The Internet!",
    "winningNumber": 42
  }
}
</code></pre>

<p>You can also update the config by sending a <code class="highlighter-rouge">PUT</code> request to config URL. Here is a simple example that will update the <code class="highlighter-rouge">Parse.Config</code>:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -d "{\"params\":{\"winningNumber\":43}}"
  https://api.parse.com/1/config
</code></pre>
<pre><code class="javascript">
var request = require('request');
return request({
  method: 'PUT',
  url: Parse.serverURL + '/config',
  headers: {
    'X-Parse-Application-Id': Parse.applicationId,
    'X-Parse-Master-Key': Parse.masterKey
  },
  json: true,
  body: {
    params: { winningNumber: 43 }
  }
})
</code></pre>

<p>The response body is a JSON object containing a simple boolean value in the <code class="highlighter-rouge">result</code> field.</p>

<pre><code class="json">
{
  "result": true
}
</code></pre>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="analytics">Analytics</h1>

<p>Parse provides a number of hooks for you to get a glimpse into the ticking heart of your app. We understand that it’s important to understand what your app is doing, how frequently, and when.</p>

<p>While this section will cover different ways to instrument your app to best take advantage of Parse’s analytics backend, developers using Parse to store and retrieve data can already take advantage of metrics on Parse.</p>

<p>Without having to implement any client-side logic, you can view real-time graphs and breakdowns (by device type, Parse class name, or REST verb) of your API Requests in your app’s dashboard and save these graph filters to quickly access just the data you’re interested in.</p>

<p>The current server time will be used for all analytics requests. To explicitly set the time associated with a given event, an optional <code class="highlighter-rouge">at</code> parameter can be provided in ISO 8601 format.</p>

<pre><code class="json">
-d '{
    "at": {
      "__type": "Date",
      "iso": "2015-03-01T15:59:11-07:00"
    }
  }
</code></pre>

<h2 id="app-open-analytics">App-Open Analytics</h2>

<p>Our analytics hook allows you to track your application being launched. By making a POST request to our REST API, you’ll begin to collect data on when and how often your application is opened.</p>

<p>In the example below, the <code class="highlighter-rouge">at</code> parameter is optional. If omitted, the current server time will be used instead.</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
      }' \
  https://api.parse.com/1/events/AppOpened
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/events/AppOpened', json.dumps({
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>Graphs and breakdowns of your statistics are accessible from your app’s Dashboard.</p>

<h2 id="custom-analytics">Custom Analytics</h2>

<p>Parse Analytics also allows you to track free-form events, with a handful of string keys and values. These extra dimensions allow segmentation of your custom events via your app’s Dashboard.</p>

<p>Say your app offers search functionality for apartment listings, and you want to track how often the feature is used, with some additional metadata.</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "dimensions": {
          "priceRange": "1000-1500",
          "source": "craigslist",
          "dayType": "weekday"
        }
      }' \
  https://api.parse.com/1/events/Search
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/events/Search', json.dumps({
       "dimensions": {
         "priceRange": "1000-1500",
         "source": "craigslist",
         "dayType": "weekday"
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>Parse Analytics can even be used as a lightweight error tracker — simply invoke the following and you’ll have access to an overview of the rate and frequency of errors, broken down by error code, in your application:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
        "dimensions": {
          "code": "404"
        }
      }' \
  https://api.parse.com/1/events/Error
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/events/Error', json.dumps({
       "dimensions": {
         "code": "404"
       }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>Note that Parse currently only stores the first eight dimension pairs per call to <code class="highlighter-rouge">/1/events/&lt;eventName&gt;</code>.</p>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="cloud-code">Cloud Code</h1>

<h2 id="cloud-functions">Cloud Functions</h2>

<p>Cloud Functions can be called using the REST API. For example, to call the Cloud Function named <code class="highlighter-rouge">hello</code>:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-REST-API-Key: ${REST_API_KEY}" \
  -H "Content-Type: application/json" \
  -d '{}' \
  https://api.parse.com/1/functions/hello
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/functions/hello', json.dumps({
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-REST-API-Key": "${REST_API_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="background-jobs">Background Jobs</h2>

<p>Similarly, you can trigger a background job from the REST API. For example, to trigger the job named <code class="highlighter-rouge">userMigration</code>:</p>

<div class="tip info"><div>
  Take a look at the <a href="/docs/cloudcode/guide#cloud-code-cloud-functions">Cloud Code Guide</a> to learn more about Cloud Functions and Background Jobs.
</div></div>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"plan":"paid"}' \
  https://api.parse.com/1/jobs/userMigration
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/jobs/userMigration', json.dumps({
       "plan": "paid"
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="schema">Schema</h1>

<p>Schema is the structure representing classes in your app. You can use the schema
of an app to verify operations in a unit test, generate test data, generate test
classes and then clean up after tests. The schema API can also be used to create
custom views of your data. We use the schema API to display columns names and 
types in the databrowser.</p>

<p>This API allows you to access the schemas of your app.
Note: This API can be only accessed using the <code class="highlighter-rouge">master key</code>.</p>

<h2 id="fetch-the-schema">Fetch the schema</h2>
<p>To fetch the Schema for all the classes of your app, run:</p>

<p>Note: <code class="highlighter-rouge">createdAt</code> and <code class="highlighter-rouge">updatedAt</code> are of type <code class="highlighter-rouge">Date</code> but they are represented
as strings in object representation. This is a special case for the Parse API.</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  https://api.parse.com/1/schemas
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/schemas', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The response body is JSON containing all the schema information of the app.</p>

<pre><code class="json">
{
  "results": [
    {
      "className": "Game",
      "fields": {
        "ACL": {
          "type": "ACL"
        },
        "createdAt": {
          "type": "Date"
        },
        "objectId": {
          "type": "String"
        },
        "name": {
          "type": "String"
        },
        "score": {
          "type": "Number"
        },
        "updatedAt": {
          "type": "Date"
        }
      }
    },
    ...
  ]
}
</code></pre>

<p>To fetch schema of a single class, run:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  https://api.parse.com/1/schemas/Game
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/schemas/Game', "", {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="adding-a-schema">Adding a schema</h2>

<p>When you add a new schema to your app, it creates an empty class with the provided
fields and some default fields applicable to the class. To add the schema, run:</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d ' 
    {
      "className": "City",
      "fields": {
        "name": {
          "type": "String"
        }
      }
    }' \
  https://api.parse.com/1/schemas/City
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/schemas/Game', json.dumps({
       "className":"City","fields":{"name":{"type":"String"} }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="modifying-the-schema">Modifying the schema</h2>

<p>You can add or delete columns to a schema. To do so, run:</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '
    {
      "className": "City",
      "fields": {
        "population": {
          "type": "Number"
        }
      }
    }' \
  https://api.parse.com/1/schemas/City
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/schemas/City', json.dumps(
       "className":"City","fields":{"population":{"type":"Number"} }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>To delete a particular field, you need to use <code class="highlighter-rouge"><span class="p">{</span><span class="nt">"__op"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"Delete"</span><span class="w"> </span><span class="p">}</span></code></p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '
    {
      "className": "City",
      "fields": {
        "population": {
          "__op": "Delete"
        }
      }
    }' \
  https://api.parse.com/1/schemas/City
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/schemas/Game', json.dumps(
       "className":"City","fields":{"population":{"__op" : "Delete"} }
     }), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<h2 id="removing-a-schema">Removing a schema</h2>

<p>You can only remove a schema from your app if it is empty (has 0 objects). 
To do that, run:</p>

<pre><code class="bash">
curl -X DELETE\
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  https://api.parse.com/1/schemas/City
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/schemas/City', "", {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="apps">Apps</h1>

<p>You can view, create, and edit your Parse apps via the REST API, in addition
to through your parse.com dashboard. By authenticating with your Parse
account’s email and password, you can fetch all the app keys for each of the
apps that you are a collaborator on, create a new app that you own, or update
the settings of an app that you are a collaborator on. This API can be used to
create test apps to run in automated tests, and in combination with the schema
API can be used to programmatically replicate your existing app into a test app.</p>

<p>Authentication for the apps endpoint is done a little differently than the rest
of the REST API. Instead of authenticating with one of your app’s keys, you must use your account’s login info.
The <code class="highlighter-rouge">X-Parse-Email</code> header identifies which account you are using,
and the <code class="highlighter-rouge">X-Parse-Password</code> header authenticates the endpoint.
If your account has no password set, because you used Facebook, GitHub, or Google
to log in, then go to <a href="https://www.parse.com/account/edit">your account page</a> to
set a password.
Alternatively, you can also generate a Parse <a href="https://parse.com/docs/js/guide#command-line-account-keys">account key</a>
and use the header <code class="highlighter-rouge">X-Parse-Account-Key</code> instead.</p>

<h2 id="fetching-apps">Fetching apps</h2>
<p>To fetch the keys and settings for all of the apps that you are a collaborator
on, run:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Email: <parse_account_email>" \
  -H "X-Parse-Password: <parse_account_password>" \
  -H "Content-Type: application/json" \
  https://api.parse.com/1/apps

<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/apps', '', {
       "X-Parse-Email": "<parse_account_email>",
       "X-Parse-Password": "<parse_account_password>",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result


The response body is JSON containing the keys and settings for your apps.

<pre><code class="json">
{
  "results": [
    {
      "appName": "<application_name>",
      "applicationId": "<application_id>",
      "clientClassCreationEnabled": true,
      "clientPushEnabled": false,
      "dashboardURL": "https://www.parse.com/apps/yourapp",
      "javascriptKey": "<javascript_key>",
      "masterKey": "<master_key>",
      "requireRevocableSessions": true,
      "restKey": "<rest_api_key>",
      "revokeSessionOnPasswordChange": true,
      "webhookKey": "<webhook_key>",
      "windowsKey": "<windows_key>"
    },
    ...
  ]
}


To fetch the keys and settings of a single app, run:

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Email: <parse_account_email>" \
  -H "X-Parse-Password: <parse_account_password>" \
  -H "Content-Type: application/json" \
  https://api.parse.com/1/apps/${APPLICATION_ID}

<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/apps/${APPLICATION_ID}', '', {
       "X-Parse-Email": "<parse_account_email>",
       "X-Parse-Password": "<parse_account_password>",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result


## Creating apps

By sending a POST request to the `/1/apps` endpoint you can create a new app,
that is owned by your account. The new app is initialized with a set of keys,
as well as some optional settings, which are all returned to you along with
the app's URL in your parse.com dashboard. The only required field for creating
an app is the app name.

The default values for the allowable settings are:

| App Setting                     | Default Value |
|---------------------------------|---------------|
| `clientClassCreationEnabled`    | true          |
| `clientPushEnabled`             | false         |
| `requireRevocableSessions`      | true          |
| `revokeSessionOnPasswordChange` | true          |

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Email: <parse_account_email>" \
  -H "X-Parse-Password: <parse_account_password>" \
  -H "Content-Type: application/json" \
  -d '{"appName":"my new app","clientClassCreationEnabled":false}' \
  https://api.parse.com/1/apps

<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/apps', json.dumps(
       "appName":"my new app","clientClassCreationEnabled":false
     }), {
       "X-Parse-Email": "<parse_account_email>",
       "X-Parse-Password": "<parse_account_password>",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result


## Updating apps

You can change your app's name, as well as change your app's settings, by sending a PUT request to `/1/apps`:

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Email: ${PARSE_ACCOUNT_EMAIL}" \
  -H "X-Parse-Password: <parse_account_password>" \
  -H "Content-Type: application/json" \
  -d '{"appName":"updated app name","clientClassCreationEnabled":true}' \
  https://api.parse.com/1/apps/${APPLICATION_ID}

<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/apps/${APPLICATION_ID}', json.dumps(
       "appName":"updated app name","clientClassCreationEnabled":true
     }), {
       "X-Parse-Email": "<parse_account_email>",
       "X-Parse-Password": "<parse_account_password>",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result

</parse_account_password></parse_account_email></code></pre></parse_account_password></code></pre></parse_account_password></parse_account_email></code></pre></parse_account_password></parse_account_email></code></pre></parse_account_password></parse_account_email></code></pre></parse_account_password></parse_account_email></code></pre></windows_key></webhook_key></rest_api_key></master_key></javascript_key></application_id></application_name></code></pre></parse_account_password></parse_account_email></code></pre></parse_account_password></parse_account_email></code></pre>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="hooks">Hooks</h1>

<p>You can create, update, list or delete all your cloud code webhooks via the Hooks API,
in addition to being able to do so through the parse website.</p>

<p>Hooks API requires the users to provide <code class="highlighter-rouge">Application-Id</code> and <code class="highlighter-rouge">Master-Key</code> in the request headers.</p>

<p>There are two kinds of cloud code webhooks: function webhooks and trigger webhooks.</p>

<p>Cloud functions are functions that run in the cloud and allow you to build functions
common to all platforms.
For more details please read <a href="https://parse.com/docs/js/guide#cloud-code-cloud-functions">cloud code functions</a>.</p>

<p>Cloud triggers are invoked whenever you save or delete a parse object.
Triggers are commonly used to validate your objects before saving them.
For more details please read <a href="https://parse.com/docs/js/guide#cloud-code-beforesave-triggers">cloud code triggers</a>.</p>

<p>Lets establish some basic terminology used throughout the rest of this section.</p>

<p><code class="highlighter-rouge">Cloud Code Webhooks</code> consist of <code class="highlighter-rouge">function webhooks</code> and <code class="highlighter-rouge">trigger webhooks</code>. This is code that runs on your servers.</p>

<p><code class="highlighter-rouge">Cloud Code</code> has <code class="highlighter-rouge">cloud code functions</code> and <code class="highlighter-rouge">cloud code triggers</code>. This is code that runs on the Parse servers.</p>

<p>These are the generic concepts encapsulating both use cases:</p>

<p><code class="highlighter-rouge">Cloud Function</code> is either a <code class="highlighter-rouge">cloud code function</code> or a <code class="highlighter-rouge">function webhook</code>.
<code class="highlighter-rouge">Cloud Trigger</code> is either a <code class="highlighter-rouge">cloud code trigger</code> or a <code class="highlighter-rouge">trigger webhook</code>.</p>

<p>A function webhook has a name and a url. Hence, its JSON response looks like:</p>
<pre><code class="json">
{"functionName": "foo", "url": "https://api.example.com/foo"}
</code></pre>

<p>JSON reponse for a cloud code function just contains the function name.</p>
<pre><code class="json">
{"functionName": "foo"}
</code></pre>

<p>A trigger webhook belongs to a class, has a trigger name and a url. Hence, its JSON response looks like:</p>
<pre><code class="json">
{"className": "score", "triggerName": "beforeSave", "url": "https://api.example.com/score/beforeSave"}
</code></pre>

<p>JSON response for a cloud code trigger contains the class name and the trigger name.</p>
<pre><code class="json">
{"className": "score", "triggerName": "beforeSave"}
</code></pre>
<p>Note that trigger name can only be one of <code class="highlighter-rouge">beforeSave</code>, <code class="highlighter-rouge">afterSave</code>, <code class="highlighter-rouge">beforeDelete</code> and <code class="highlighter-rouge">afterDelete</code>.</p>

<h2 id="fetch-functions">Fetch functions</h2>
<p>To fetch the list of all cloud functions you deployed or created, use:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  https://api.parse.com/1/hooks/functions
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/hooks/functions', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The output is a json object with one key: “results” whose value is a list of cloud functions.</p>
<pre><code class="json">
{
  "results": [
    { "functionName": "sendMessage", "url": "https://api.example.com/sendMessage" },
    { "functionName": "sendMessage" },
    { "functionName": "foo", "url": "https://api.example.com/foo" },
    { "functionName": "bar" }
  ]
}
</code></pre>

<p>To fetch a single cloud function with a given name, use:</p>

<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  https://api.parse.com/1/hooks/functions/sendMessage
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/hooks/functions/sendMessage', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The output is a json object with one key: “results” whose value is a list of cloud functions with the given name.</p>

<pre><code class="json">
{
  "results": [
    { "functionName": "sendMessage", "url": "https://api.example.com/sendMessage" },
    { "functionName": "sendMessage" }
  ]
}
</code></pre>

<h2 id="fetch-triggers">Fetch triggers</h2>
<p>To fetch the list of all cloud triggers you deployed or created, use:</p>
<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  https://api.parse.com/1/hooks/triggers
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/hooks/triggers', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The output is a json object with one key: “results” whose value is a list of cloud triggers.</p>
<pre><code class="json">
{
  "results": [
    { "className": "Scores", "triggerName": "beforeSave" },
    {
      "className": "Scores",
      "triggerName": "beforeSave",
      "url": "https://api.example.com/Scores/beforeSave"
    },
    {
      "className": "Game",
      "triggerName": "afterSave",
      "url": "https://api.example.com/Game/afterSave"
    },
    { "className": "Tournament", "triggerName": "beforeDelete" }
  ]
}
</code></pre>

<p>To fetch a single cloud trigger, use:</p>
<pre><code class="bash">
curl -X GET \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  https://api.parse.com/1/hooks/triggers/Scores/beforeSave
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('GET', '/1/hooks/triggers/Scores/beforeSave', '', {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The path looks like <code class="highlighter-rouge">/hooks/triggers/className/triggerName</code> where <code class="highlighter-rouge">triggerName</code>
can be one of <code class="highlighter-rouge">beforeSave</code>, <code class="highlighter-rouge">afterSave</code>, <code class="highlighter-rouge">beforeDelete</code>, <code class="highlighter-rouge">afterDelete</code>.</p>

<p>The output may look like this:</p>
<pre><code class="json">
{
  "results": [
    { "className": "Scores", "triggerName": "beforeSave" },
    {
      "className": "Scores",
      "triggerName": "beforeSave",
      "url": "https://api.example.com/Scores/beforeSave"
    }
  ]
}
</code></pre>

<p>The output is a json object with one key: “results” whose value is a list of all
cloud triggers with given name for a given class.</p>

<p>Note that POST, PUT and DELETE only work on function or trigger webhooks.
To create cloud code functions or cloud code triggers you can modify your cloud code javascript files
and perform a <code class="highlighter-rouge">parse deploy</code> the usual way.</p>

<h2 id="create-function-webhook">Create function webhook</h2>
<p>To create a new function webhook post to <code class="highlighter-rouge">/1/hooks/functions</code> with payload in the format</p>
<pre><code class="bash">
{"functionName" : x, "url" : y}
</code></pre>

<p>Post example,</p>

<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"functionName":"baz","url":"https://api.example.com/baz"}' \
  https://api.parse.com/1/hooks/functions
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/hooks/functions', json.dumps(
       {"functionName":"baz","url":"https://api.example.com/baz"}
     ), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The output may look like this:</p>
<pre><code class="json">
{"functionName": "baz", "url": "https://api.example.com/baz"}'
</code></pre>

<p>It returns the function name and url of the created webhook.</p>

<p>If you try to create a function webhook and a cloud code function with the same name already exists, upon successful creation the response json has an additional <code class="highlighter-rouge">warning</code> field informing about the name conflict. Note that, function webhooks takes precedence over cloud code functions.</p>

<p>For example,</p>
<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"functionName":"bar","url":"https://api.example.com/bar"}' \
  https://api.parse.com/1/hooks/functions
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/hooks/functions', json.dumps(
       {"functionName":"bar","url":"https://api.example.com/bar"}
     ), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The output may look like this:</p>
<pre><code class="json">
{
  "functionName": "bar",
  "url": "https://api.example.com/bar",
  "warning": "a cloudcode function with name: bar already exists"
}
</code></pre>

<h2 id="create-trigger-webhook">Create trigger webhook</h2>
<p>To create a new function webhook post to <code class="highlighter-rouge">/1/hooks/triggers</code> with payload in the format</p>
<pre><code class="bash">
{"className": x, "triggerName": y, "url": z}
</code></pre>
<pre><code class="python">
{"className": x, "triggerName": y, "url": z}
</code></pre>

<p>Post example,</p>
<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"className": "Game", "triggerName": "beforeSave", "url": "https://api.example.com/Game/beforeSave"}' \
https://api.parse.com/1/hooks/triggers
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/hooks/triggers', json.dumps(
       {"className": "Game", "triggerName": "beforeSave", "url": "https://api.example.com/Game/beforeSave"}
     ), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The output may look like this:</p>
<pre><code class="json">
{
  "className": "Game",
  "triggerName": "beforeSave",
  "url": "https://api.example.com/Game/beforeSave"
}
</code></pre>

<p>It returns the class name, trigger name and url of the created trigger webhook.</p>

<p>If you try to create a trigger webhook and a cloud code trigger with the same name already exists, upon successful creation the response json has an additional <code class="highlighter-rouge">warning</code> field informing about the name conflict. Note that, trigger webhooks takes precedence over cloud code triggers.</p>

<p>For example,</p>
<pre><code class="bash">
curl -X POST \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"className": "Tournament", "triggerName": "beforeDelete", "url": "https://api.example.com/Scores/beforeDelete"}' \
https://api.parse.com/1/hooks/triggers
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('POST', '/1/hooks/triggers', json.dumps(
       {"className": "Tournament", "triggerName": "beforeDelete", "url": "https://api.example.com/Scores/beforeDelete"}
     ), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The output may look like this:</p>
<pre><code class="json">
{
  "className": "Tournament",
  "triggerName": "beforeDelete",
  "url": "https://api.example.com/Tournament/beforeDelete",
  "warning": "beforeDelete trigger already defined for class Tournament in cloud code"
}
</code></pre>

<h2 id="edit-function-webhook">Edit function webhook</h2>
<p>To edit the url of a function webhook that was already created use the put method.</p>

<p>Put example,</p>
<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"url":"https://api.example.com/_baz"}' \
  https://api.parse.com/1/hooks/functions/baz
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/hooks/functions/baz', json.dumps(
    {"url":"https://api.example.com/_baz"}
      ), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The output may look like this:</p>
<pre><code class="json">
{"functionName": "baz", "url": "https://api.example.com/baz"}'
</code></pre>

<p>It returns the function name and url of the modified webhook.</p>

<p>If you try to update a function webhook and a cloud code function with the same name already exists, upon successful update the response json has an additional <code class="highlighter-rouge">warning</code> field informing about the name conflict. Note that, function webhooks takes precedence over cloud code functions.</p>

<p>For example,</p>
<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"url":"https://api.example.com/_bar"}' \
  https://api.parse.com/1/hooks/functions/bar
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/hooks/functions/bar', json.dumps(
      {"url":"https://api.example.com/_bar"}
      ), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The output may look like this:</p>
<pre><code class="json">
{
  "functionName": "bar",
  "url": "https://api.example.com/_bar",
  "warning": "a cloudcode function with name: bar already exists"
}
</code></pre>

<h2 id="edit-trigger-webhook">Edit trigger webhook</h2>
<p>To edit the url of a trigger webhook that was already crated use the put method.</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"url": "https://api.example.com/Game/_beforeSave"}' \
https://api.parse.com/1/hooks/triggers/Game/beforeSave
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/hooks/triggers/Game/beforeSave', json.dumps(
      {"url": "https://api.example.com/Game/_beforeSave"}
      ), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The output may look like this:</p>
<pre><code class="json">
{
  "className": "Game",
  "triggerName": "beforeSave",
  "url": "https://api.example.com/Game/_beforeSave"
}
</code></pre>

<p>It returns the class name, trigger name and url of the modified trigger webhook.</p>

<p>If you try to update a trigger webhook and a cloud code trigger with the same name already exists, upon successful update the response json has an additional <code class="highlighter-rouge">warning</code> field informing about the name conflict. Note that, trigger webhooks takes precedence over cloud code triggers.</p>

<p>For example,</p>
<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"url": "https://api.example.com/Scores/beforeDelete"}' \
https://api.parse.com/1/hooks/triggers/Tournament/beforeDelete
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/hooks/triggers/Tournament/beforeDelete', json.dumps(
      {"url": "https://api.example.com/Scores/beforeDelete"}
      ), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The output may look like this:</p>
<pre><code class="json">
{
  "className": "Tournament",
  "triggerName": "beforeDelete",
  "url": "https://api.example.com/Tournament/beforeDelete",
  "warning": "beforeDelete trigger already defined for class Tournament in cloud code"
}
</code></pre>

<h2 id="delete-function-webhook">Delete function webhook</h2>
<p>To delete a function webhook use the put method.</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{"__op": "Delete"}' \
https://api.parse.com/1/hooks/functions/foo
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/hooks/functions/foo', json.dumps(
      {"__op": "Delete"}
      ), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The output may look like this:</p>
<pre><code class="json">
{}
</code></pre>

<p>If a cloud code function with the same name already exists then it is returned as the result.
Since the overriding webhook was just deleted, this cloud code function will be run the next time sendMessage is called.</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{ "__op": "Delete" }' \
https://api.parse.com/1/hooks/functions/sendMessage
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/hooks/functions/sendMessage', json.dumps(
      {"__op": "Delete"}
      ), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The output may look like this:</p>
<pre><code class="json">
{ "functionName": "sendMessage" }
</code></pre>

<h2 id="delete-trigger-webhook">Delete trigger webhook</h2>
<p>To delete a trigger webhook use the put method.</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{ "__op": "Delete" }' \
https://api.parse.com/1/hooks/triggers/Game/beforeSave
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/hooks/triggers/Game/beforeSave', json.dumps(
      {"__op": "Delete"}
      ), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The output may look like this:</p>
<pre><code class="json">
{}
</code></pre>

<p>If a cloud code trigger with the same name already exists then the it is returned as the result.
Since the overriding webhook was just deleted, this cloud code trigger will be run the next time a Tournament object is saved.</p>

<pre><code class="bash">
curl -X PUT \
  -H "X-Parse-Application-Id: ${APPLICATION_ID}" \
  -H "X-Parse-Master-Key: ${MASTER_KEY}" \
  -H "Content-Type: application/json" \
  -d '{ "__op": "Delete" }' \
https://api.parse.com/1/hooks/triggers/Tournament/beforeDelete
</code></pre>
<pre><code class="python">
import json,httplib
connection = httplib.HTTPSConnection('api.parse.com', 443)
connection.connect()
connection.request('PUT', '/1/hooks/triggers/Tournament/beforeDelete', json.dumps(
      {"__op": "Delete"}
      ), {
       "X-Parse-Application-Id": "${APPLICATION_ID}",
       "X-Parse-Master-Key": "${MASTER_KEY}",
       "Content-Type": "application/json"
     })
result = json.loads(connection.getresponse().read())
print result
</code></pre>

<p>The output may look like this:</p>
<pre><code class="json">
{
  "className": "Tournament",
  "triggerName": "beforeDelete"
}
</code></pre>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                    
                    <h1 id="error-codes">Error Codes</h1>

<p>The following is a list of all the error codes that can be returned by the Parse API. You may also refer to <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">RFC2616</a> for a list of http error codes. Make sure to check the error message for more details.</p>

<h2 id="api-issues">API Issues</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Code</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">UserInvalidLoginParams</code></td>
      <td>101</td>
      <td>Invalid login parameters. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ObjectNotFound</code></td>
      <td>101</td>
      <td>The specified object or session doesn’t exist or could not be found. Can also indicate that you do not have the necessary permissions to read or write this object. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidQuery</code></td>
      <td>102</td>
      <td>There is a problem with the parameters used to construct this query. This could be an invalid field name or an invalid field type for a specific constraint. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidClassName</code></td>
      <td>103</td>
      <td>Missing or invalid classname. Classnames are case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the only valid characters.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">MissingObjectId</code></td>
      <td>104</td>
      <td>An unspecified object id.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidFieldName</code></td>
      <td>105</td>
      <td>An invalid field name. Keys are case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the only valid characters. Some field names may be reserved. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidPointer</code></td>
      <td>106</td>
      <td>A malformed pointer was used. You would typically only see this if you have modified a client SDK.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidJSON</code></td>
      <td>107</td>
      <td>Badly formed JSON was received upstream. This either indicates you have done something unusual with modifying how things encode to JSON, or the network is failing badly. Can also indicate an invalid utf-8 string or use of multiple form encoded values. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">CommandUnavailable</code></td>
      <td>108</td>
      <td>The feature you tried to access is only available internally for testing purposes.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">NotInitialized</code></td>
      <td>109</td>
      <td>You must call Parse.initialize before using the Parse library. Check the Quick Start guide for your platform.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ObjectTooLarge</code></td>
      <td>116</td>
      <td>The object is too large. Parse Objectss have a max size of 128 kilobytes.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ExceededConfigParamsError</code></td>
      <td>116</td>
      <td>You have reached the limit of 100 config parameters.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidLimitError</code></td>
      <td>117</td>
      <td>An invalid value was set for the limit. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidSkipError</code></td>
      <td>118</td>
      <td>An invalid value was set for skip. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">OperationForbidden</code></td>
      <td>119</td>
      <td>The operation isn’t allowed for clients due to class-level permissions. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">CacheMiss</code></td>
      <td>120</td>
      <td>The result was not found in the cache.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidNestedKey</code></td>
      <td>121</td>
      <td>An invalid key was used in a nested JSONObject. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidACL</code></td>
      <td>123</td>
      <td>An invalid ACL was provided.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidEmailAddress</code></td>
      <td>125</td>
      <td>The email address was invalid.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">DuplicateValue</code></td>
      <td>137</td>
      <td>Unique field was given a value that is already taken.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidRoleName</code></td>
      <td>139</td>
      <td>Role’s name is invalid.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ReservedValue</code></td>
      <td>139</td>
      <td>Field value is reserved.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ExceededCollectionQuota</code></td>
      <td>140</td>
      <td>You have reached the quota on the number of classes in your app. Please delete some classes if you need to add a new class.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ScriptFailed</code></td>
      <td>141</td>
      <td>Cloud Code script failed. Usually points to a JavaScript error. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">FunctionNotFound</code></td>
      <td>141</td>
      <td>Cloud function not found. Check that the specified Cloud function is present in your Cloud Code script and has been deployed.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">JobNotFound</code></td>
      <td>141</td>
      <td>Background job not found. Check that the specified job is present in your Cloud Code script and has been deployed.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">SuccessErrorNotCalled</code></td>
      <td>141</td>
      <td>success/error was not called. A cloud function will return once response.success() or response.error() is called. A background job will similarly finish execution once status.success() or status.error() is called. If a function or job never reaches either of the success/error methods, this error will be returned. This may happen when a function does not handle an error response correctly, preventing code execution from reaching the success() method call.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">MultupleSuccessErrorCalls</code></td>
      <td>141</td>
      <td>Can’t call success/error multiple times. A cloud function will return once response.success() or response.error() is called. A background job will similarly finish execution once status.success() or status.error() is called. If a function or job calls success() and/or error() more than once in a single execution path, this error will be returned.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ValidationFailed</code></td>
      <td>142</td>
      <td>Cloud Code validation failed.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">WebhookError</code></td>
      <td>143</td>
      <td>Webhook error.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidImageData</code></td>
      <td>150</td>
      <td>Invalid image data.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">UnsavedFileError</code></td>
      <td>151</td>
      <td>An unsaved file.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidPushTimeError</code></td>
      <td>152</td>
      <td>An invalid push time was specified.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">HostingError</code></td>
      <td>158</td>
      <td>Hosting error.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidEventName</code></td>
      <td>160</td>
      <td>The provided analytics event name is invalid.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ClassNotEmpty</code></td>
      <td>255</td>
      <td>Class is not empty and cannot be dropped.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">AppNameInvalid</code></td>
      <td>256</td>
      <td>App name is invalid.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">MissingAPIKeyError</code></td>
      <td>902</td>
      <td>The request is missing an API key.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidAPIKeyError</code></td>
      <td>903</td>
      <td>The request is using an invalid API key.</td>
    </tr>
  </tbody>
</table>

<h2 id="push-related-errors">Push related errors</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Code</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">IncorrectType</code></td>
      <td>111</td>
      <td>A field was set to an inconsistent type. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidChannelName</code></td>
      <td>112</td>
      <td>Invalid channel name. A channel name is either an empty string (the broadcast channel) or contains only a-zA-Z0-9_ characters and starts with a letter.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidSubscriptionType</code></td>
      <td>113</td>
      <td>Bad subscription type. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidDeviceToken</code></td>
      <td>114</td>
      <td>The provided device token is invalid.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">PushMisconfigured</code></td>
      <td>115</td>
      <td>Push is misconfigured in your app.  Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">PushWhereAndChannels</code></td>
      <td>115</td>
      <td>Can’t set channels for a query-targeted push. You can fix this by moving the channels into your push query constraints.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">PushWhereAndType</code></td>
      <td>115</td>
      <td>Can’t set device type for a query-targeted push. You can fix this by incorporating the device type constraints into your push query.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">PushMissingData</code></td>
      <td>115</td>
      <td>Push is missing a ‘data’ field.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">PushMissingChannels</code></td>
      <td>115</td>
      <td>Non-query push is missing a ‘channels’ field. Fix by passing a ‘channels’ or ‘query’ field.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ClientPushDisabled</code></td>
      <td>115</td>
      <td>Client-initiated push is not enabled. Check your Parse app’s push notification settings.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">RestPushDisabled</code></td>
      <td>115</td>
      <td>REST-initiated push is not enabled. Check your Parse app’s push notification settings.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ClientPushWithURI</code></td>
      <td>115</td>
      <td>Client-initiated push cannot use the “uri” option.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">PushQueryOrPayloadTooLarge</code></td>
      <td>115</td>
      <td>Your push query or data payload is too large. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidExpirationError</code></td>
      <td>138</td>
      <td>Invalid expiration value.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">MissingPushIdError</code></td>
      <td>156</td>
      <td>A push id is missing. Deprecated.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">MissingDeviceTypeError</code></td>
      <td>157</td>
      <td>The device type field is missing. Deprecated.</td>
    </tr>
  </tbody>
</table>

<h2 id="file-related-errors">File related errors</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Code</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">InvalidFileName</code></td>
      <td>122</td>
      <td>An invalid filename was used for Parse File. A valid file name contains only a-zA-Z0-9_. characters and is between 1 and 128 characters.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">MissingContentType</code></td>
      <td>126</td>
      <td>Missing content type.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">MissingContentLength</code></td>
      <td>127</td>
      <td>Missing content length.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidContentLength</code></td>
      <td>128</td>
      <td>Invalid content length.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">FileTooLarge</code></td>
      <td>129</td>
      <td>File size exceeds maximum allowed.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">FileSaveError</code></td>
      <td>130</td>
      <td>Error saving a file.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">FileDeleteError</code></td>
      <td>131</td>
      <td>File could not be deleted.</td>
    </tr>
  </tbody>
</table>

<h2 id="installation-related-errors">Installation related errors</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Code</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">InvalidInstallationIdError</code></td>
      <td>132</td>
      <td>Invalid installation id.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidDeviceTypeError</code></td>
      <td>133</td>
      <td>Invalid device type.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidChannelsArrayError</code></td>
      <td>134</td>
      <td>Invalid channels array value.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">MissingRequiredFieldError</code></td>
      <td>135</td>
      <td>Required field is missing.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ChangedImmutableFieldError</code></td>
      <td>136</td>
      <td>An immutable field was changed.</td>
    </tr>
  </tbody>
</table>

<h2 id="purchase-related-errors">Purchase related errors</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Code</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">ReceiptMissing</code></td>
      <td>143</td>
      <td>Product purchase receipt is missing.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidPurchaseReceipt</code></td>
      <td>144</td>
      <td>Product purchase receipt is invalid.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">PaymentDisabled</code></td>
      <td>145</td>
      <td>Payment is disabled on this device.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidProductIdentifier</code></td>
      <td>146</td>
      <td>The product identifier is invalid.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ProductNotFoundInAppStore</code></td>
      <td>147</td>
      <td>The product is not found in the App Store.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidServerResponse</code></td>
      <td>148</td>
      <td>The Apple server response is not valid.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ProductDownloadFilesystemError</code></td>
      <td>149</td>
      <td>The product fails to download due to file system error.</td>
    </tr>
  </tbody>
</table>

<h2 id="user-related-errors">User related errors</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Code</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">UsernameMissing</code></td>
      <td>200</td>
      <td>The username is missing or empty.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">PasswordMissing</code></td>
      <td>201</td>
      <td>The password is missing or empty.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">UsernameTaken</code></td>
      <td>202</td>
      <td>The username has already been taken.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">UserEmailTaken</code></td>
      <td>203</td>
      <td>Email has already been used.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">UserEmailMissing</code></td>
      <td>204</td>
      <td>The email is missing, and must be specified.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">UserWithEmailNotFound</code></td>
      <td>205</td>
      <td>A user with the specified email was not found.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">SessionMissing</code></td>
      <td>206</td>
      <td>A user object without a valid session could not be altered.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">MustCreateUserThroughSignup</code></td>
      <td>207</td>
      <td>A user can only be created through signup.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">AccountAlreadyLinked</code></td>
      <td>208</td>
      <td>An account being linked is already linked to another user.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidSessionToken</code></td>
      <td>209</td>
      <td>The device’s session token is no longer valid. The application should ask the user to log in again.</td>
    </tr>
  </tbody>
</table>

<h2 id="linked-services-errors">Linked services errors</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Code</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">LinkedIdMissing</code></td>
      <td>250</td>
      <td>A user cannot be linked to an account because that account’s id could not be found.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidLinkedSession</code></td>
      <td>251</td>
      <td>A user with a linked (e.g. Facebook or Twitter) account has an invalid session. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidGeneralAuthData</code></td>
      <td>251</td>
      <td>Invalid auth data value used.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">BadAnonymousID</code></td>
      <td>251</td>
      <td>Anonymous id is not a valid lowercase UUID.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">FacebookBadToken</code></td>
      <td>251</td>
      <td>The supplied Facebook session token is expired or invalid.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">FacebookBadID</code></td>
      <td>251</td>
      <td>A user with a linked Facebook account has an invalid session.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">FacebookWrongAppID</code></td>
      <td>251</td>
      <td>Unacceptable Facebook application id.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">TwitterVerificationFailed</code></td>
      <td>251</td>
      <td>Twitter credential verification failed.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">TwitterWrongID</code></td>
      <td>251</td>
      <td>Submitted Twitter id does not match the id associated with the submitted access token.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">TwitterWrongScreenName</code></td>
      <td>251</td>
      <td>Submitted Twitter handle does not match the handle associated with the submitted access token.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">TwitterConnectFailure</code></td>
      <td>251</td>
      <td>Twitter credentials could not be verified due to problems accessing the Twitter API.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">UnsupportedService</code></td>
      <td>252</td>
      <td>A service being linked (e.g. Facebook or Twitter) is unsupported. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">UsernameSigninDisabled</code></td>
      <td>252</td>
      <td>Authentication by username and password is not supported for this application. Check your Parse app’s authentication settings.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">AnonymousSigninDisabled</code></td>
      <td>252</td>
      <td>Anonymous users are not supported for this application. Check your Parse app’s authentication settings.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">FacebookSigninDisabled</code></td>
      <td>252</td>
      <td>Authentication by Facebook is not supported for this application. Check your Parse app’s authentication settings.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">TwitterSigninDisabled</code></td>
      <td>252</td>
      <td>Authentication by Twitter is not supported for this application. Check your Parse app’s authentication settings.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InvalidAuthDataError</code></td>
      <td>253</td>
      <td>An invalid authData value was passed. Check error message for more details.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">LinkingNotSupportedError</code></td>
      <td>999</td>
      <td>Linking to an external account not supported yet with signup_or_login. Use update instead.</td>
    </tr>
  </tbody>
</table>

<h2 id="client-only-errors">Client-only errors</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Code</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">ConnectionFailed</code></td>
      <td>100</td>
      <td>The connection to the Parse servers failed.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">AggregateError</code></td>
      <td>600</td>
      <td>There were multiple errors. Aggregate errors have an “errors” property, which is an array of error objects with more detail about each error that occurred.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">FileReadError </code></td>
      <td>601</td>
      <td>Unable to read input for a Parse File on the client.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">XDomainRequest</code></td>
      <td>602</td>
      <td>A real error code is unavailable because we had to use an XDomainRequest object to allow CORS requests in Internet Explorer, which strips the body from HTTP responses that have a non-2XX status code.</td>
    </tr>
  </tbody>
</table>

<h2 id="operational-issues">Operational issues</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Code</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">RequestTimeout</code></td>
      <td>124</td>
      <td>The request was slow and timed out. Typically this indicates that the request is too expensive to run. You may see this when a Cloud function did not finish before timing out, or when a <code class="highlighter-rouge">Parse.Cloud.httpRequest</code> connection times out.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InefficientQueryError</code></td>
      <td>154</td>
      <td>An inefficient query was rejected by the server. Refer to the Performance Guide and slow query log.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">RequestLimitExceeded</code></td>
      <td>155</td>
      <td>This application has exceeded its request limit (legacy Parse.com apps only).</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">TemporaryRejectionError</code></td>
      <td>159</td>
      <td>An application’s requests are temporary rejected by the server (legacy Parse.com apps only).</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">DatabaseNotMigratedError</code></td>
      <td>428</td>
      <td>You should migrate your database as soon as possible (legacy Parse.com apps only).</td>
    </tr>
  </tbody>
</table>

<h2 id="other-issues">Other issues</h2>

<table class="docs_table">
  <thead>
    <tr>
      <th>Name</th>
      <th>Code</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">OtherCause</code></td>
      <td>-1</td>
      <td>An unknown error or an error unrelated to Parse occurred.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">InternalServerError</code></td>
      <td>1</td>
      <td>Internal server error. No information available.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ServiceUnavailable</code></td>
      <td>2</td>
      <td>The service is currently unavailable.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">ClientDisconnected</code></td>
      <td>4</td>
      <td>Connection failure.</td>
    </tr>
  </tbody>
</table>


                    

<div class="helpful">
	<span>Want to contribute to this doc? <a href="https://github.com/parseplatform/docs/tree/gh-pages/_includes/rest">Edit this section.</a></span>
	<hr/>
</div>

                  
                </div>

              </div>
          		<!-- footer goes here -->
            </div>
          </div><!-- end content grid col -->
        </div><!-- end .guide > .grid-container -->
      </div><!-- /.content__wrapper -->
    </div><!-- /.site__content -->
  </div><!-- /.site__wrapper -->

  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/highlight.min.js"></script>
  <script src="/docs/assets/js/bundle.js"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
  <script type="text/javascript"> docsearch({
    apiKey: 'c7f5661ba53e2e3c1c3752696362209e',
    indexName: 'parse',
    inputSelector: '#algolia-doc-search',
    algoliaOptions: { 'facetFilters': ["tags:rest"] }, // android, arduino, cloudcode, dotnet, embedded_c, ios, js, macos, parse-server, php, rest, unity
    debug: false // Set debug to true if you want to inspect the dropdown
  });
  </script>
</body>

</html>
